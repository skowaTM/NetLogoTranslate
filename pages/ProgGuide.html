<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Руководство пользователя NetLogo 6.4.0: руководство по программированию</title>
    <link rel="stylesheet" href="../assets/css/ProgGuideStyle.css">
</head>

<body>
    <h1>Руководство по программированию на языке NetLogo</h1>
    <div class="version">Руководство пользователя NetLogo 6.4.0</div>

    <p>В этом разделе подробно описывается язык программирования NetLogo.</p>
    <p>Примеры кода, на которые ссылается руководство, можно найти в разделе Code Examples Библиотеки Моделей.</p>
    <ul>
        <li><a href="#Agents">Агенты</a></li>
        <li><a href="#Procedures">Процедуры</a></li>
        <li><a href="#Variables">Переменные</a></li>
        <li><a href="#Tick-counter">Счетчик Тиков</a></li>
        <li><a href="#Colors">Цвета в NetLogo</a></li>
        <li><a href="#Ask">Ask</a></li>
        <li><a href="#Agentsets">Agentsets</a></li>
        <li><a href="#Breeds">Виды</a></li>
        <li><a href="#Buttons">Кнопки</a></li>
        <li><a href="#Lists">Списки</a></li>
        <li><a href="#Maths">Математика</a></li>
        <li><a href="#Random-Numbers">Случайные числа</a></li>
        <li><a href="#Turtle-shapes">Формы черепах</a></li>
        <li><a href="#Link-shapes">Формы связей</a></li>
        <li><a href="#View-update">Обновление экрана</a></li>
        <li><a href="#Plots">Графики</a></li>
        <li><a href="#Strings">Строки</a></li>
        <li><a href="#Output">Вывод</a></li>
        <li><a href="#File-I/O">Файловый ввод/вывод</a></li>
        <li><a href="#Movies">Видеоролики</a></li>
        <li><a href="#Perspective">Перспектива</a></li>
        <li><a href="#Drawing">Холст</a></li>
        <li><a href="#Topology">Топология</a></li>
        <li><a href="#Links">Связи</a></li>
        <li><a href="#Anonymous-procedures">Анонимные процедуры</a></li>
        <li><a href="#Ask-concurrent">Ask-concurrent</a></li>
        <li><a href="#User-interaction-primitives">Примитивы взаимодействия с пользователем</a></li>
        <li><a href="#Tie">Связывание</a></li>
        <li><a href="#Multiple-source-files">Множество исходных файлов</a></li>
        <li><a href="#Syntax">Синтаксис</a></li>
    </ul>


    <h2 id="Agents">Агенты</h2>
    <div class="dict_entry">
        <p>Мир NetLogo состоит из агентов. Агенты - это существа, которые могут следовать инструкциям.</p>
        <p>В NetLogo существует четыре типа агентов: черепахи, патчи, связи и наблюдатель.</p>
        <p>Черепахи - это агенты, которые перемещаются по миру. Мир является двумерным и разделен на множество участков - патчей. Патч представляет собой квадратный 
            участок “земли”, по которому могут передвигаться черепахи. Связи - это агенты, соединяющие двух черепах. У наблюдателя нет определенного местоположения 
            – вы можете считать, что это сущность, которая смотрит на мир черепах и патчей.</p>
        <p>Наблюдатель наблюдает не пассивно – он дает инструкции другим агентам.</p>
        <p>Когда NetLogo запускается, в мире нет черепах. Наблюдатель может создавать новых черепах. Патчи также могут создавать новых черепах. 
            (Патчи не могут двигаться, но в остальном они такие же “живые”, как и черепахи.)</p>
        <p>Патчи имеют координаты. Патч с координатами (0, 0) называется началом координат, а координаты других патчей - это расстояния по горизонтали и вертикали 
            от этого патча. Мы называем координаты патча pxcor и pycor. Как и в стандартной математической координатной плоскости, pxcor увеличивается
            при перемещении вправо (на восток), а pycor увеличивается при перемещении вверх (на север).</p>
        <p>Общее число патчей определяется настройками min-pxcor, max-pxcor, min-pycor и max-pycor. При запуске NetLogo значения min-pxcor, max-pxcor, min-pycor и 
            max-pycor равны -16, 16, -16 и 16 соответственно. Это значит, что значения pxcor, pycor варьируются от -16 до 16; таким образом, 
            изначально создается всего на 1089 патчей. (Вы можете изменить количество патчей с помощью кнопки Settings ("Установки").</p>
        <p>У черепах тоже есть координаты: xcor и ycor. Координаты патча всегда являются целыми числами, координаты черепашки могут быть и дробными. 
            Это означает, что черепашку можно расположить в любой точке патча, а не только в его центре.</p>
        <p>Связи не имеют координат. У каждой связи есть два конца, и каждый конец - это черепашка. Если одна из черепашек умирает, связь тоже умирает. 
            Связь визуально представлена в виде линии, соединяющей двух черепашек.</p>
    </div>
    
    <h2 id="Procedures">Процедуры</h2>
    <div class="dict_entry">
        <p>В NetLogo существуют команды и репортеры, они определяют действия агентов. Команда - это действие, которое должен выполнить агент, 
            приводящее к некоторому результату. Репортер - это инструкция по вычислению значения, которое затем возвращается тому, кто попросил его вычисления.</p>
        <p>Как правило, название команды начинается с глагола, например create, die, jump, inspect и т.д. 
            Большинство имен репортеров - это существительные или словосочетания.</p>
        <p>Встроенные команды NetLogo называются примитивами. Словарь NetLogo содержит полный список примитивов.</p>
        <p>Команды и репортеры, которые Вы определяете сами, называются процедурами. Каждая процедура имеет имя, которому предшествует ключевое слово to или 
            to-report - оно определяет, является процедура командной или репортером. Ключевое слово end обозначает конец процедуры. 
            Как только Вы определите процедуру, Вы сможете использовать ее в любом месте Вашей программы.</p>
        <p>Многие команды и репортеры имеют входные параметры – значения, которые команда или репортер использует при выполнении своих действий или вычислении результата.</p>
        <pre>
to setup
  clear-all
  create-turtles 10
  reset-ticks
end

to go
  ask turtles [
    fd 1            ;; forward 1 step
    rt random 10    ;; turn right
    lt random 10    ;; turn left
  ]
  tick
end
        </pre>
        <p>Обратите внимание на использование точек с запятой для добавления комментариев к программе. 
            Комментарии облегчают чтение и понимание Вашего кода, но не влияют на его поведение.</p>
        <p>В данном коде:</p>
        <ul>
            <li>Определены процедуры setup и go.</li>
            <li>clear-all, create-turtles, reset-ticks, ask, lt (“left turn”), rt (“right turn”) и tick - команды-примитивы NetLogo.</li>
            <li>random и turtles - репортеры-примитивы. random принимает одно число в качестве входных данных и возвращает случайное целое число, которое меньше 
                исходного (в данном случае от 0 до 9). turtles возвращает agentset, включающий всех черепах (об agentset мы поговорим позже).</li>
        </ul>
        <p>setup и go могут быть вызваны другими процедурами, кнопками или из Командного Центра.</p>
        <p>В NetLogo Вы можете указать, какие агенты – черепахи, патчи или связи – должны запустить команду. Если Вы не укажете, код будет запущен наблюдателем.
            В приведенном выше коде наблюдатель использует ask, чтобы заставить всех черепах выполнять команды, указанные в квадратных скобках.</p>
        <p>Существуют команды, которые могут быть запущены только определенным видом агентов. Так, clear-all может выполнить только наблюдатель, а fd - только черепаха.</p>

        <p><b>Процедуры с входными параметрами</b></p>

        <p>Процедуры могут принимать входные данные, как и многие примитивы. Чтобы создать процедуру, которая имеет входные параметры, 
            заключите их названия в квадратные скобки после названия процедуры. Например:</p>
        <pre>
to draw-polygon [num-sides len]  ;; turtle procedure
  pen-down
  repeat num-sides [
    fd len
    rt 360 / num-sides
  ]
end
        </pre>
        <p>Теперь вы можете воспользоваться этой процедурой, попросив черепах нарисовать восьмиугольник с длиной стороны, равной их переменной who:</p>
        <pre>ask turtles [ draw-polygon 8 who ]</pre>
        
        <p><b>Процедуры-репортеры</b></p>
        <p>Точно так же, как Вы можете определять свои собственные команды, Вы можете определять свои собственные репортеры. Для этого:
        <ul> 
            <li>Во-первых, используйте to-report вместо to для объявления процедуры.</li>
            <li>Во-вторых, в теле процедуры используйте report, чтобы вернуть нужное значение.</li>
        </ul>
        </p>
        <pre>
to-report absolute-value [number]
  ifelse number >= 0
    [ report number ]
    [ report (- number) ]
end
        </pre>
    </div>

    <h2 id="Variables">Переменные</h2>
    <div class="dict_entry">
        <p><b>Переменные агентов</b></p>
        <p>Переменные агентов - это места для хранения значений (например, чисел) в агенте. Переменная агента может быть глобальной переменной, переменной черепахи, 
            патча или связи.</p>
        <p>Если переменная является глобальной, то ее значение едино для всех агентов, и каждый агент может получить к ней доступ. 
            Вы можете считать, что глобальные переменные принадлежат наблюдателю.</p>
        <p>Переменные черепахи, патча и связи отличаются от глобальных. Каждая черепаха имеет свое собственное значение для "черепашьей" переменной. 
            То же самое касается переменных патчей и связей.</p>
        <p>Существуют встроенные переменные. Например, все черепахи и связи имеют встроенную переменную color, а у всех патчей есть переменная pcolor
           (переменные патчей начинаются с “p”, чтобы отличать их от похожих переменных черепах, поскольку черепахи имеют прямой доступ к переменным патчей).
        </p>
        <p>Также встроенными являются переменные xcor, ycor и heading у черепах и pxcor, pycor для патчей (полный список встроенных переменных приведен в
            <a href="Dictionary.html">Словаре NetLogo</a>).</p>
        <p>Вы также можете определять свои собственные переменные. Вы можете создать глобальную переменную, добавив переключатель, ползунок, поле выбора или поле ввода
            в свою модель или используя ключевое слово globals в начале своего кода, например, так:</p>
        <pre>globals [score]</pre>
        <p>Вы также можете определить новые переменные черепахи, патча или связи, используя ключевые слова turtles-own, 
            patches-own и links-own соответственно, например, так:</p>
        <pre>
turtles-own [energy speed]
patches-own [friction]
links-own [strength]
        </pre>
        <p>Затем эти переменные можно свободно использовать в модели. Для установки значения используйте команду set
            (если значение не было установлено, переменная имеет значение по умолчанию, равное нулю).</p>
        <p>Глобальные переменные могут быть прочитаны и изменены любым агентом в любое время.</p>
        <p>Черепаха может читать и изменять переменные патча, на котором она стоит. Например, этот код</p>
        <pre>ask turtles [ set pcolor red ]</pre>
        <p>приводит к тому, что каждая черепашка выделяет красным цветом тот патч, на котором она стоит 
            (поскольку переменные патча доступны черепахам, Вы не можете создать переменную черепахи и переменную патча с одинаковыми именами).</p>
        <p>Если Вы хотите, чтобы агент прочитал переменную другого агента, Вы можете использовать of. Пример:</p>
        <pre>
show [color] of turtle 5
;; prints current color of turtle with who number 5
        </pre>
        <p>Вы также можете использовать of с более сложными выражениями, чем доступ к переменной, например:</p>
        <pre>
show [xcor + ycor] of turtle 5
;; prints the sum of the x and y coordinates of
;; turtle with who number 5
        </pre>

        <p><b>Локальные переменные</b></p>
        <p>Локальная переменная определяется и используется только в контексте конкретной процедуры или ее части. Чтобы создать локальную переменную, используйте команду let.
            Если Вы используете let в начале процедуры, переменная будет существовать на протяжении всей процедуры. Если Вы используете let внутри квадратных скобок, 
            например, внутри “ask”, то переменная будет существовать только внутри этих скобок.</p>
        <pre>
to swap-colors [turtle1 turtle2]
  let temp [color] of turtle1
  ask turtle1 [ set color [color] of turtle2 ]
  ask turtle2 [ set color temp ]
end
        </pre>
    </div>

    <h2 id="Tick-counter">Счетчик тиков</h2>
    <div class="dict_entry">
        <p>Во многих моделях NetLogo время протекает дискретными шагами, называемыми “тиками”. В NetLogo есть 
            встроенный счетчик тиков, чтобы отслеживать, сколько тиков прошло с запуска модели.</p>
        <p>Текущее значение счетчика тиков отображается в верхней части окна (вы можете использовать кнопку Settings (Установки), 
            чтобы скрыть счетчик тиков, или заменить подпись “тики” на что-то другое).</p>
        <p>В коде для получения текущего значения счетчика тиков используйте репортер ticks. Команда tick увеличивает значение 
            счетчика тиков на 1. Команда clear-all очищает счетчик тиков вместе со всем остальным.</p>
        <p>Когда счетчик тиков очищен, попытка прочитать или изменить его вызовет ошибку. После завершения настройки вашей модели используйте 
            команду reset-ticks, чтобы установить счетчику тиков значение 0.</p>
        <p>Если ваша модель установлена на обновление по тикам, то команда tick также обновит экран. 
            Смотрите раздел <a href="#View-update">Обновление экрана</a>.</p>
        
        <h3>Работа с счетчиком</h3>
        <div class="dict_entry">
            <p>Используйте reset-ticks в конце процедуры setup и tick в конце процедуры go.</p>
            <pre>
to setup
  clear-all
  create-turtles 10
  reset-ticks
end

to go
  ask turtles [ fd 1 ]
  tick
end
            </pre>
        </div>

        <h3>Нецелые тики</h3>
        <div class="dict_entry">
            <p>В большинстве моделей счетчик тиков начинается с 0 и увеличивается на 1. Однако, счетчик тиков может работать с дробными числами.
                Чтобы увеличить счетчик тиков на дробную величину, используйте команду <a href="Dictionary.html#tick-advance">tick-advance</a>.</p>
            <p>Обычно нецелые тики используются для аппроксимации непрерывного или криволинейного движения. Например, модель GasLab в Библиотеке Моделей 
                (в разделе Chemistry & Physics) вычисляет точное время, в которое должно произойти событие, 
                а затем переводит счетчик тиков точно на это время.</p>
        </div>
    </div>

    <h2 id="Colors">Цвета в NetLogo</h2>
    <div class="dict_entry">
        <p>NetLogo представляет цвета по-разному. Цвет может быть представлен значением от 0 до 140 (не включая 140). Ниже приведена диаграмма, 
            показывающая диапазон таких цветов NetLogo.</p>
        <p class="image"><img src="https://ccl.northwestern.edu/netlogo/docs/images/colors.jpg"></p>
        <p>Диаграмма показывает, что:</p>
        <ul>
            <li>У некоторых цветов есть названия (Вы можете использовать эти названия в своем коде).</li>
            <li>Каждый именованный цвет, кроме черного и белого, имеет номер, оканчивающийся на 5.</li>
            <li>По обе стороны от именованного цвета расположены темные и светлые оттенки этого цвета.</li>
            <li>0 - чистый черный цвет, 9.9 - чистый белый.</li>
            <li>10, 20 и так далее настолько темные, что кажутся черными.</li>
            <li>19.9, 29.9 и так далее настолько светлые, что кажутся белыми.</li>
        </ul>
        <p><b>Пример кода:</b> диаграмма была сделана с помощью модели Color Chart Example.</p>
        <p>Если Вы используете число вне диапазона [0, 140), NetLogo прибавит или вычтет 140 из этого числа столько раз, чтобы оно оказалось в диапазоне от 0 до 140.
            Например, 25 - это оранжевый цвет, поэтому 165, 305, 445 и так далее - тоже оранжевый, как и -115, -255, -395 и т.д.
            Такое приведение цвета выполняется автоматически всякий раз, когда Вы задаете значение переменных color у черепахи и pcolor у патча. 
            Если Вам нужно выполнить такой расчет в каком-либо другом контексте, используйте примитив <a href="Dictionary.html#wrap-color">wrap-color</a>.
        </p>
        <p>Если Вам нужен цвет, которого нет на графике, вы можете использовать дробные числа. Например, 26,5 - это оттенок оранжевого, находящийся 
            между цветами 26 и 27. Это не значит, что вы можете задать любой цвет в палитре NetLogo; цветовое пространство NetLogo - это лишь подмножество всех возможных 
            цветов. Оно содержит только фиксированный набор оттенков (по одному оттенку на строку диаграммы). Для данных оттенков Вы можете либо уменьшить 
            яркость (затемнить), либо уменьшить насыщенность (осветлить), но Вы не можете уменьшить одновременно яркость и насыщенность.
            Помимо этого, значение имеет только первая цифра после запятой. Значения цвета округляются в меньшую сторону до десятых долей, так что, например, между цветами 
            26,5 и 26,52 или 26,58 разницы не будет.</p>
        
        <p><b>Примитивы для работы с цветами</b></p>
        <p>Мы уже упомянули <a href="Dictionary.html#wrap-color">wrap-color</a>.</p>
        <p>Примитив <a href="Dictionary.html#scale-color">scale-color</a> используется для преобразования числовых значений в цвета.</p>
        <p><a href="Dictionary.html#shade-of?">shade-of?</a> покажет, являются ли два цвета “оттенками” одного и того же основного цвета. 
            Например, shade-of? orange 27 вернет true, потому что 27 - это более светлый оттенок оранжевого.</p>
        <p><b>Пример кода:</b> Scale-color Example демонстрирует работу scale-color.</p>

        <p><b>Цвета RGB и RGBA</b></p>
        <p>NetLogo также представляет цвета в виде списков RGB (красный/зеленый/синий) и RGBA (красный/зеленый/синий/альфа). При использовании цветов RGB вам доступен 
            весь спектр цветов. RGBA представляет все цвета, которые представляет RGB, но при этом позволяет изменять прозрачность цвета (альфа).
            Списки RGB и RGBA состоят из трех или четырех целых чисел соответственно, от 0 до 255. Вы можете задать для любых цветовых переменных в NetLogo 
            (color для черепашек и связей и pcolor для патчей) значение RGB-списка, и этот агент будет отображаться с соответствующим цветом.
            Так, например, Вы можете окрасить патч 0 0 в красный цвет, используя следующий код:</p>
        <pre>set pcolor [255 0 0]</pre>
        <p>Черепахи, связи и метки (labels) могут содержать списки RGBA в качестве цветовых переменных. Патчи используют альфа-значение RGBA только в NetLogo 3D,
             в 2D NetLogo оно игнорируется. Вы можете установить цвет черепахи примерно наполовину прозрачным красным, используя следующий код:</p>
        <pre>set color [255 0 0 125]</pre>
        <p>Вы можете преобразовать цвет NetLogo в RGB или HSB (hue/saturation/brightness - оттенок/насыщенность/яркость), используя 
            <a href="Dictionary.html#extract-hsb">extract-hsb</a> и <a href="Dictionary.html#extract-rgb">extract-rgb</a>. 
            Вы можете использовать <a href="Dictionary.html#rgb">rgb</a> для создания списков RGB и <a href="Dictionary.html#hsb">hsb</a> для преобразования цвета HSB в RGB.</p>
        <p>Поскольку в цветовом пространстве NetLogo отсутствуют многие цвета, 
            <a href="Dictionary.html#approximate-hsb">approximate-hsb</a> и <a href="Dictionary.html#approximate-rgb">approximate-rgb</a>
            часто не могут вернуть точный цвет, который Вы запрашиваете, но они стараются максимально приблизить его.</p>
        <p><b>Например:</b></p>
        <pre>
let my-color approximate-rgb 0 0 255 ;; my-color is now 104.7
show extract-rgb my-color ;; shows [48 88 161] which is pretty far from [0 0 255], the color we started with
        </pre>
        <p>Это аппроксимация, но она все еще близка к blue, которое равно 105.</p>
        <p>Используя цвета RGBA, у пользователя появляется больше возможностей, когда дело доходит до выбора цвета агента.</p>
        <p>Например: вы можете изменить цвет любой черепахи с цвета NetLogo на более прозрачный вариант этого цвета, используя:</p>
        <pre>ask one-of turtles [set color lput 102 extract-rgb color]</pre>
        <p><b>Замечание:</b> поскольку значение 255 является полностью непрозрачным, а 60 процентов прозрачности равно 40-ка процентам непрозрачности, 
                правильное значение параметра альфа равно 255 * 0.4 = 102. Смотрите альтернативную реализацию в разделе "Расширение palette" ниже.</p>
            
        <p><b>Пример кода:</b> HSB and RGB Example, Transparency Example.</p>

        <p><b>Расширение palette</b></p>
        <p>Расширение palette предлагает примитивы, которые дают пользователю больше контроля над цветами.
            Это позволяет напрямую манипулировать компонентами RGB и HSB, не прибегая к работе над списками.</p>
        <p>Пример: изменить прозрачность случайной черепахи на шестьдесят процентов с помощью palette можно так:</p>
        <pre>
extensions [palette]
ask one-of turtles [palette:set-transparency 60]
        </pre>
        <p>Расширение предлагает аналогичные команды для компонент красного, зеленого, синего, Альфа, оттенка, насыщенности и яркости.</p>
        <p>Дополнительную информацию смотрите в <a href="https://ccl.northwestern.edu/netlogo/docs/palette.html">документации</a> расширения.</p>
        <p><b>Пример кода:</b> Palette Example, Color Bubbles, Color Painting, Color Reveal.</p>

        <p><b>Окно образцов цветов</b></p>
        <p>Окно образцов цветов (Color Swatches) может помочь с выбором цвета. Оно доступно в меню Средства (Tools).</p>
        <p class="image"><img src="https://ccl.northwestern.edu/netlogo/docs/images/programming/colorswatches.gif"></p>
        <p>Когда вы нажимаете на цвета, он отображается на фоне других цветов. В левом нижнем углу отображается код для текущего цвета (например, red + 2), 
            который Вы можете скопировать и вставить в свой код. В правом нижнем углу указано расширение палитры - оно определяет 
            разницу между соседними отображаемыми цветами. Так, при инкременте 1, в строке конкретного цвета будет 10 оттенков, а при инкременте 0,1 в строке будет 100 оттенков.</p>
    </div>

    <h2 id="Ask">Ask</h2>
    <div class="dict_entry">
        <p>NetLogo использует команду <a href="Dictionary.html#ask">ask</a> для отправки команд черепахам, патчам и связям. Весь код, который должен выполняться черепахой, 
            должен находиться в ее “контексте”. Вы можете задать контекст тремя способами:</p>
            <ul>
                <li>С помощью кнопки. Для этого выберете черепах в качестве агентов-исполнителей. Код, указанный в кнопке, будет выполнен всеми черепахами.</li>
                <li>В Командном Центре, выбрав черепах в качестве агентов-исполнителей кода. Все команды, которые Вы введете, будут выполнены всеми черепахами.</li>
                <li>Используя команду ask turtles, hatch или другую команду, которая предоставляет контекст.</li>
            </ul>
        <p>То же самое относится к патчам, связям и наблюдателю, за исключением того, что вы не можете использовать ask с наблюдателем. 
            Любой код вне контекста команды ask по умолчанию является кодом observer.</p>
        <p>Поскольку элементы agentset всегда считываются в случайном порядке, при использовании ask с agentset агенты будут выполнять команды  
            в случайном порядке. Дополнительную информацию смотрите в разделе <a href="#Agentsets">Agentsets</a>.</p>
        <p>Пример использования команды ask:</p>
        <pre>
to setup
  clear-all
  create-turtles 100   ;; create 100 turtles with random headings
  ask turtles
    [ set color red    ;; turn them red
      fd 50 ]          ;; spread them around
  ask patches
    [ if pxcor > 0         ;; patches on the right side
        [ set pcolor green ] ]  ;; of the view turn green
  reset-ticks
end
        </pre>
        <p>Так же в качестве примера можно обратиться почти к любой модели из Библиотеки Моделей, в первую очередь из раздела Code Examples.</p>
        <p>Обычно наблюдатель использует ask, чтобы запросить выполнение команд у всех черепашек, всех патчей или всех связей. Вы также можете использовать ask, 
            чтобы запустить команды для определенных черепах, патчей или связей. Для этого используются репортеры 
            <a href="Dictionary.html#turtle">turtle</a>, <a href="Dictionary.html#patch">patch</a>, <a href="Dictionary.html#link">link</a> 
            и <a href="Dictionary.html#patch-at">patch-at</a>. Например:</p>
        <pre>
to setup
  clear-all
  crt 3                           ;; make 3 turtles
  ask turtle 0                    ;; tell the first one...
    [ fd 1 ]                      ;; ...to go forward
  ask turtle 1                    ;; tell the second one...
    [ set color green ]           ;; ...to become green
  ask turtle 2                    ;; tell the third one...
    [ rt 90 ]                     ;; ...to turn right
  ask patch 2 -2                  ;; ask the patch at (2,-2)
    [ set pcolor blue ]           ;; ...to become blue
  ask turtle 0                    ;; ask the first turtle
    [ ask patch-at 1 0            ;; ...to ask patch to the east
      [ set pcolor red ] ]        ;; ...to become red
  ask turtle 0                    ;; tell the first turtle...
    [ create-link-with turtle 1 ] ;; ...make a link with the second
  ask link 0 1                    ;; tell the link between turtle 0 and 1
    [ set color blue ]            ;; ...to become blue
  reset-ticks
end
        </pre>
        <p>У каждой созданной черепахи есть переменная who с уникальным значением. Первая созданная черепаха имеет номер 0, вторая черепаха - номер 1 и так далее.</p>
        <p>Примитив <a href="Dictionary.html#turtle">turtle</a> принимает число в качестве параметра и возвращает черепаху с who, равным этому параметру.
            Примитив <a href="Dictionary.html#patch">patch</a> принимает pxcor и pycor и возвращает патч с этими координатами. Примитив <a href="Dictionary.html#link">link</a> 
            принимает два входных параметра - переменные who двух черепах, и возвращает связь между ними, если она существует.
            Примитив <a href="Dictionary.html#patch-at">patch-at</a> использует смещения: расстояния в направлениях x и y от вызвавшего команду агента, и возвращает патч в точке смещения.
            В приведенном выше примере процедуры setup черепаху с who = 0 просят установить цвет патчу на востоке от нее  
            следующим образом: ask turtle 0 [ ask patch-at 1 0 [ set pcolor red ] ].</p>
        <p>Вы также можете создать agentset черепах, патчей или связей и указать команды для него (см. <a href="#Agentsets">Agentsets</a>)</p>
        <p>Если вы работаете с agentset, важно знать, что агенты выполняют команды по очереди (следующий агент начнет выполнение только после того, как текущий агент 
            закончит выполнение). Например, если Вы напишете:</p>
        <pre>
ask turtles
  [ fd 1
    set color red ]
        </pre>
        <p>сначала одна черепаха сделает шаг вперед и изменит свой цвет на красный, затем другая и т.д.</p>
        <p>Однако, если Вы напишите это так:</p>
        <pre>
ask turtles [ fd 1 ]
ask turtles [ set color red ]
        </pre>
        <p>сначала все черепахи сделают шаг вперед, и только потом будут по очереди менять свой цвет.</p>
    </div>

    <h2 id="Agentsets">Agentsets</h2>
    <div class="dict_entry">
        <p>Agentset - это множество агентов. Agentset может содержать черепах, патчи или связи (все агенты в agentset имеют один тип).</p>
        <p>Agentset не является упорядоченным объектом и агенты в нем всегда расположены в случайном порядке, притом порядок этот случаен при каждом вызове (т.е. каждый раз
            первая черепахой, к которой обратятся через agentset, будет разной).</p>
        <p>Мы уже сталкивались с примитивами <a href="Dictionary.html#turtles">turtles</a>, <a href="Dictionary.html#patches">patches</a> и 
            <a href="Dictionary.html#links">links</a>,
            которые возвращают agentset всех черепах, патчей и связей мира соответственно.</p>
        <p>Сила agentset заключается в том, что Вы можете включить в него только некоторых, нужных Вам агентов. Например, красных черепах, патчи с pxcor кратным пяти или 
            все связи черепахи с who = 0. Затем Вы можете использовать <a href="Dictionary.html#ask">ask</a> или сделать этот agentset входным параметром какой-либо команды.</p>
        <p>Например, Вы можете использовать <a href="Dictionary.html#turtles-here">turtles-here</a>, <a href="Dictionary.html#turtles-at">turtles-at</a> или 
            <a href="Dictionary.html#turtles-on">turtles-on</a> для создания agentset черепах с определенным положением (см. описание функций в Словаре Netlogo).</p>
        <p>Некоторые примеры создания agentset:</p>
        <pre>
;; all other turtles:
other turtles
;; all other turtles on this patch:
other turtles-here
;; all red turtles:
turtles with [color = red]
;; all red turtles on my patch
turtles-here with [color = red]
;; patches on right side of view
patches with [pxcor > 0]
;; all turtles less than 3 patches away
turtles in-radius 3
;; the four patches to the east, north, west, and south
patches at-points [[1 0] [0 1] [-1 0] [0 -1]]
;; shorthand for those four patches
neighbors4
;; turtles in the first quadrant that are on a green patch
turtles with [(xcor > 0) and (ycor > 0)
              and (pcolor = green)]
;; turtles standing on my neighboring four patches
turtles-on neighbors4
;; all the links connected to turtle 0
[my-links] of turtle 0
        </pre>
        <p>Обратите внимание на использование <a href="Dictionary.html#other">other</a>, который исключает вызывающего агента из множества-аргумента.</p>
        <p>После того, как Вы создали agentset, вы можете:</p>
        <ul>
            <li>Использовать команду ask, чтобы заставить агентов в множестве что-то сделать.</li>
            <li>Использовать <a href="Dictionary.html#any?">any?</a> чтобы узнать, пуст ли agentset.</li>
            <li>Использовать <a href="Dictionary.html#all?">all?</a> чтобы проверить, удовлетворяет ли каждый агент в agentset какому-либо условию.</li>
            <li>Использовать <a href="Dictionary.html#count">count</a>, чтобы узнать, сколько агентов находится в множестве.</li>
        </ul>
        <p>Более сложные выражения с agentset:</p>
        <ul>
            <li>
                <p>Можно выбрать случайного агента из множества, используя <a href="Dictionary.html#one-of">one-of</a>. 
                Например, мы можем сделать так, чтобы случайно выбранная черепаха стала зеленой: </p>
                <pre style="margin-left: 0;">ask one-of turtles [ set color green ]</pre>
                <p>Или сказать случайному патчу создать черепаху:</p>
                <pre style="margin-left: 0;">ask one-of patches [ sprout 1 ]</pre>
            </li>
            <li>
                <p>С использованием <a href="Dictionary.html#max-one-of">max-one-of</a> или <a href="Dictionary.html#min-one-of">min-one-of</a> 
                    можно определить агента с самым большим/маленьким показателем по какой-либо шкале. Например:</p>
                <pre style="margin-left: 0;">ask max-one-of turtles [sum assets] [ die ]</pre>
            </li>
            <li>
                <p>Вы можете построить гистограмму используя команду <a href="Dictionary.html#histogram">histogram</a> (в сочетании с <a href="Dictionary.html#of">of</a>).</p>
            </li>
            <li>
                <p>Вы можете использовать <a href="Dictionary.html#of">of</a> для построения списка по agentset и затем использовать этот 
                    список в качестве аргумента примитива (см. <a href="#Lists">Списки</a>). Например, Вы можете вычислить среднее значение параметра 
                    assets всех черепах так:</p>
                <pre style="margin-left: 0;">show mean [sum assets] of turtles</pre>
            </li>
            <li>
                <p>Вы можете использовать <a href="Dictionary.html#turtle-set">turtle-set</a>, <a href="Dictionary.html#patch-set">patch-set</a> 
                    или <a href="Dictionary.html#link-set">link-set</a>, чтобы создать
                agentset из агентов из разных мест.</p>
            </li>
            <li>
                <p>Вы можете создать пустой agentset определенного типа с помощью
                    <a href="Dictionary.html#no-turtles">no-turtles</a>,  <a href="Dictionary.html#no-patches">no-patches</a> или 
                    <a href="Dictionary.html#no-links">no-links</a>.
                </p>
            </li>
            <li>
                <p>Вы можете сравнить два agentset на равенство используя <a href="Dictionary.html#arithmeticoperators">=</a> или 
                    <a href="Dictionary.html#arithmeticoperators">!=</a>.</p>
            </li>
            <li>
                <p>Можно проверить, принадлежит ли агент множеству с помощью <a href="Dictionary.html#member?">member?</a></p>
            </li>
        </ul>
        <p>Это лишь некоторые примеры работы с множествами агентов. Примеры использования также приведены в Библиотеке Моделей. Помимо этого, Вы можете обратиться к Словарю
            NetLogo - он содержит полный список доступных над agentset операций.</p>
        
        <h3>Специальные agentset'ы</h3>
        <p>Множества turtles и links ведут себя по-особому, поскольку они всегда содержат всех черепах и все связи. 
            Следовательно, эти наборы агентов могут увеличиваться.</p>
        <p>Следующий код демонстрирует их особое поведение. Положим, что в разделе "Код" есть следующее: globals [g]. Тогда:</p>
        <pre>
observer> clear-all
observer> create-turtles 5
observer> set g turtles
observer> print count g
5
observer> create-turtles 5
observer> print count g
10
observer> set g turtle-set turtles
observer> print count g
10
observer> create-turtles 5
observer> print count g
10
observer> print count turtles
15
        </pre>
        <p>При создании черепах расширяется только turtles. Если, например, создать новое множество на основе turtles так: turtle-set turtles, то при рождении новой
            черепахи оно не увеличится.</p>
        <p>Agentset конкретного вида ведут себя так же, но включают только агентов этого вида. См. <a href="#Breeds">Виды</a></p>

        <h3>Agentset'ы и списки</h3>
        <p>Мы уже упомянули, что агенты в множестве представлены в случайном порядке. Если Вам важен порядок агентов, используйте <a href="#Lists">Списки</a>.</p>
        <p><b>Пример кода:</b>Ask Ordering Example.</p>
    </div>
    
    <h2 id="Breeds">Виды</h2>
    <div class="dict_entry">
        <p>NetLogo позволяет определять собственные "виды" (с англ. breed - порода, вид) черепах и связей. После определения вида вы можете задать ему свое поведение 
            (отличное от других видов). Например, вы можете задать виды sheep(овцы) и wolves(волки), при этом волки будут "есть" овец.</p>
        <p>Для определения вида используйте ключевое слово <a href="Dictionary.html#breed">breed</a> в начале раздела "Код" вашей модели, перед определением процедур:</p>
        <pre>
breed [wolves wolf]
breed [sheep a-sheep]
        </pre>
        <p>Вы можете обратиться к представителю вида, используя форму единственного числа, подобно <a href="Dictionary.html#turtle">turtle</a>. 
            При выводе представители вида будут помечены.</p>
        <p>В некоторых командах название вида указывается во множественном числе, например, <a href="Dictionary.html#create-turtles">create-&lt;breeds&gt;</a>. В других командах 
            используется единственное число как <a href="Dictionary.html#turtle">&lt;breed&gt;</a>.</p>
        <p>Порядок, в котором указаны виды, также определяет порядок их расположения на экране. Виды, определенные позже, 
            будут отображаться поверх видов, определенных ранее; в примере выше овцы будут рисоваться поверх волков.</p>
        <p>Когда Вы определяете вид, например, sheep, автоматически создается agentset для этого вида, так что все возможности множеств агентов, описанные выше, 
            сразу же становятся доступными и для sheep.</p>
        <p>
            Следующие примитивы также автоматически становятся доступны, как только Вы определяете вид (на примере sheep):
            <a href="Dictionary.html#create-turtles">create-sheep</a>,
            <a href="Dictionary.html#hatch">hatch-sheep</a>, 
            <a href="Dictionary.html#sprout">sprout-sheep</a>, 
            <a href="Dictionary.html#turtles-here">sheep-here</a>, 
            <a href="Dictionary.html#turtles-at">sheep-at</a>, 
            <a href="Dictionary.html#turtles-on">sheep-on</a>, 
            <a href="Dictionary.html#is-of-type">is-a-sheep?</a>
        </p>
        <p>Вы также можете использовать команду <a href="Dictionary.html#turtles-own">sheep-own</a> для определения переменных, доступных только представителям вида.</p>
        <p>Вид черепахи хранится в ее переменной <a href="Dictionary.html#breed">breed</a> черепахи. Так, например, Вы можете проверить вид черепахи следующим образом:</p>
        <pre>if breed = wolves [ ... ]</pre>
        <p>Черепахи могут менять свой вид (через изменение значения ее переменной breed):</p>
        <pre>ask one-of wolves [ set breed sheep ]</pre>
        <p>Примитив <a href="Dictionary.html#set-default-shape">set-default-shape</a> полезен для задания определенной формы черепахам определенного вида. 
            Подробнее о формах <a href="#Turtle-shapes">тут</a>.</p>
        <p>Переменным who значение присваивается независимо от вида. Если у Вас есть агент sheep 0, то новый агент wolve будет иметь who = 1, но не 0.</p>
        <p>Пример использования видов:</p>
        <pre>
breed [mice mouse]
breed [frogs frog]
mice-own [cheese]
to setup
  clear-all
  create-mice 50
    [ set color white
      set cheese random 10 ]
  create-frogs 50
    [ set color green ]
  reset-ticks
end
        </pre>
        <p><b>Пример кода:</b> Breeds and Shapes Example.</p>
    </div>

    <h3>Виды связей</h3>
    <p>Виды связей очень похожи на виды черепах, однако есть несколько отличий.</p>
    <p>Когда Вы объявляете вид для связей, Вы должны указать, для каких связей определяется вид - для направленных или ненаправленных. 
        Используйте для этого <a href="Dictionary.html#directed-link-breed">directed-link-breed</a> и <a href="Dictionary.html#undirected-link-breed">undirected-link-breed</a>.</p>
    <pre>
directed-link-breed [streets street]
undirected-link-breed [friendships friendship]
    </pre>
    <p>Ссылки одного вида могут быть либо направленными, либо ненаправленными.</p>
    <p>Виды ссылок также используются в командах, как и виды черепах, например, 
        <a href="Dictionary.html#link-neighbor?">&lt;link-breed&gt;-neighbor?</a>.
    </p>
    <p>
        После определения вида для направленных связей становятся доступны следующие примитивы (на примере вида streets):
        <a href="Dictionary.html#create-link">create-street-from</a>,
        <a href="Dictionary.html#create-link">create-streets-from</a>,
        <a href="Dictionary.html#create-link">create-street-to</a>,
        <a href="Dictionary.html#create-link">create-streets-to</a>,
        <a href="Dictionary.html#in-link-neighbor">in-street-neighbor?</a>,
        <a href="Dictionary.html#in-link-neighbors">in-street-neighbors</a>,
        <a href="Dictionary.html#in-link-from">in-street-from</a>,
        <a href="Dictionary.html#my-in-links">my-in-streets</a>,
        <a href="Dictionary.html#my-out-links">my-out-streets</a>,
        <a href="Dictionary.html#out-link-neighbor?">out-street-neighbor?</a>,
        <a href="Dictionary.html#out-link-neighbors">out-street-neighbors</a>,
        <a href="Dictionary.html#out-link-to">out-street-to</a>.
    </p>
    <p>
        После определения вида для ненаправленных связей становятся доступны следующие примитивы:
        <a href="Dictionary.html#create-link">create-friendship-with</a>,
        <a href="Dictionary.html#create-link">create-friendships-with</a>,
        <a href="Dictionary.html#link-neighbor?">friendship-neighbor?</a>,
        <a href="Dictionary.html#link-neighbors">friendship-neighbors</a>,
        <a href="Dictionary.html#link-with">friendship-with</a>,
        <a href="Dictionary.html#my-links">my-friendships</a>.
    </p>
    <p>Виды связей также могут определять собственные переменные 
        (с помощью <a href="Dictionary.html#links-own">&lt;link-breeds&gt;-own</a>), 
        но эта переменная не может быть общей для видов черепах и связей.</p>
    <p>Как и с черепахами, порядок, в котором объявляются виды связей, определяет порядок, в котором отображаются.</p>
    <p>Вы можете изменить вид связи с помощью set breeds (однако Вы не можете удалить вид у связи).</p>
    <pre>
ask one-of friendships [ set breed streets ]
ask one-of friendships [ set breed links ] ;; produces a runtime error
    </pre>
    <p><a href="Dictionary.html#set-default-shape">set-default-shape</a> также можно использовать с видом связи.</p>
    <p><b>Пример кода:</b> Link Breeds Example.</p>

    <h2 id="Buttons">Кнопки</h2>
    <div class="dict_entry">
        <p>Кнопки Интерфейса позволяют удобно управлять моделью. Обычно в модели есть, по крайней мере, кнопка "setup" для начальной настройки мира и кнопка "go" 
            для запуска модели. Модели так же могут иметь дополнительные кнопки, которые выполняют другие действия.</p>
        <p>Кнопка содержит некоторый код NetLogo. Этот код запускается при нажатии на нее.</p>
        <p>Кнопки различаются по режиму работы. Кнопки с режимом Once (с англ. Единожды, Один раз) запускают код один раз, кнопки с режимом 
            Forever (с англ. Всегда, Бесконечно) запускают код повторно сразу после выполнения. Режим работы определяется в окне редактирования кнопки.</p>
        <p>Forever-кнопка прекращает работу после повторного нажатия. Кнопка ожидает завершения текущей итерации и останавливается.</p>
        <p>Forever-кнопка также может быть остановлена из кода. Если такая кнопка напрямую вызывает процедуру, то при завершении этой процедуры кнопка останавливает работу.
            (В случае, если Forever-кнопка работает с черепахами/патчами, она не прекратит работу, пока код не выполнят все черепахи/патчи – 
            одна черепаха или патч не смогут остановить работу кнопки).</p>
        <p>Обычно кнопка подписана кодом, который она запускает. Например, кнопка с меткой "go" чаще всего просто запускает процедуру "go".
            Однако Вы можете задать кнопке отображаемое имя. Вы можете использовать это, если считаете, что фактический код может быть непонятным пользователю.</p>
        <p>Когда Вы создаете кнопку, Вы должны указать, какие агенты будут использоваться для запуска этого кода. Вы можете выбрать, 
            чтобы код запускал наблюдатель, все черепахи, все патчи или все связи (если Вы хотите, чтобы код запускался только определенными агентами, 
            Вы можете создать кнопку наблюдателя, а затем использовать команду ask).</p>
        <p>Также у Вас есть возможность назначить клавишу клавиатуры, эта клавиша будет активировать код кнопки (так же, как если бы Вы нажали на нее в интерфейсе). 
            Если кнопка установлена в режим Forever, она будет оставаться нажатой (и выполнять действия) до тех пор, пока клавиша не будет нажата снова 
            (или на кнопку не нажмут через интерфейс). Клавиши управления особенно полезны для игр или любой другой модели, где требуется быстрое нажатие кнопок.</p>
        
        <p><b>Одновременные нажатия</b></p>
        <p>Возможны ситуации, когда одновременно оказываются нажаты несколько кнопок. NetLogo запускает кнопки по очереди - другие кнопки не начнут работу, пока текущая
            кнопка не закончит выполнение.</p>
        <p>Пусть setup является Once-кнопкой, go - Forever-кнопкой.</p>
        <p>Пример №1: Пользователь нажимает setup, затем сразу же нажимает go, прежде чем setup закончит работу. Результат: setup завершается, затем запускается go.</p>
        <p>Пример №2: Пользователь нажимает setup когда кнопка go нажата. Результат: кнопка go завершает текущую итерацию, затем запускается кнопка setup, 
            затем go запускается снова.</p>
        <p>Пример №3: Пользователь нажимает две Forever-кнопки одновременно. Результат: сначала одна кнопка выполняет свой код до конца, затем другая выполняет свой код,
            и так далее по очереди.</p>
        <p>Обратите внимание, что если какая-либо кнопка застрянет в бесконечном цикле, то другие кнопки не будут работать.</p>
            
        <p><b>Кнопки черепах, патчей, связей</b></p>
        <p>Существует небольшая разница между вводом команд в Forever-кнопке черепахи, патча или связи и вводом тех же команд в кнопку наблюдателя с использованием 
            ask turtles/patches/links. Команда ask не считается завершенной, пока все запрашиваемые агенты не выполнят код. Во время выполнения они могу быть "не синхронизированы",
            однако во время завершения ask они все точно "синхронизированы". Forever-кнопки же заставляют каждого агента запускать код снова и снова, без оглядки на остальных
            агентов. Таким оразом, при использовании кнопки все агенты остаются "рассинхронизироваными".</p>
        <p>В настоящий момент в Библиотеке Моделей эта особенность демонстрируется очень редко. Один из примеров - модель Biology/Termites. Кнопка go - 
            это Forever-кнопка, поэтому каждый термит движется независимо от других термитов, и наблюдатель никак не участвует в этом. 
            Это значит, что если, например, Вы захотите добавить тики и/или график в модель, Вам нужно будет создать вторую forever-кнопку и запустить их 
            одновременно. Также обратите внимание, что подобная модель не может быть использована с Behavior Space.</p>
    </div>

    <h2 id="Lists">Списки</h2>
    <div class="dict_entry">
        <p>В простейших моделях каждая переменная содержит одно значение (обычно это число или строка). Списки позволяют хранить несколько фрагментов информации в одной 
            переменной. Каждое значение в списке может иметь любой тип: число, строка, агент, agentset или даже другой список.</p>
        <p>Списки позволяют удобно работать с множеством значений. Если агенты выполняют повторяющиеся вычисления над несколькими переменными, удобнее будет 
            использовать переменную-список вместо нескольких различных переменных. Существует ряд примитивов, которые упрощают процесс выполнения операций 
            над списком и его элементами.</p>
        <p>В <a href="Dictionary.html">Словаре NetLogo</a> приведен полный список примитивов, работающих со списками.</p>
        <p><b>Списки-константы</b></p>
        <p>Вы можете создать список просто поместив нужные значения в квадратные скобки: set mylist [2 4 6 8]. Обратите внимание, что значения разделены пробелами.
            Таким образом Вы можете создавать списки, содержащие числа и строки, а также другие списки, например, [[2 4] [3 5]]. </p>
        <p>Пустой список записывается так: [].</p>
        
        <p><b>Построение списков</b></p>
        <p>Если Вы хотите собрать список из значений, возвращаемых репортерами, используйте <a href="Dictionary.html#list">list</a>. Команда принимает на вход два репортера
            и помещает возвращаемые ими значения в список. Например, чтобы получить список с двумя случайными числами, можно написать:</p>
        <pre>set random-list list (random 10) (random 20)</pre>
        <p>Чтобы создавать более короткие/длинные списки, заключите команду list и ее аргументы в круглые скобки:</p>
        <pre>
(list random 10)
(list random 10 random 20 random 30)
        </pre>
        <p>Иногда список проще всего создать с помощью команды <a href="Dictionary.html#n-values">n-values</a>: она создает список определенной длины путем многократного запуска
            заданного репортера.</p>
        <p>Примитив <a href="Dictionary.html#of">of</a> позволяет создать список из agentset. Он возвращает список, содержащий значения репортера, вычисленные для каждого агента 
            (репортер может быть как просто переменной, так и более сложным выражением, и даже вызовом процедуры, 
            определенной с помощью <a href="Dictionary.html#to-report">to-report</a>).</p>
        <pre>
max [...] of turtles
sum [...] of turtles
        </pre>
        <p>Также можно объединить элементы и списки в один большой, используя команду <a href="Dictionary.html#sentence">sentence</a>.</p>
        
        <p><b>Изменения списков</b></p>
        <p>Технически, изменять списки нельзя, но Вы можете создавать новые списки на основе старых. Если Вы хотите, чтобы новый список заменил старый, используйте 
            <a href="Dictionary.html#set">set</a>. Например:</p>
        <pre>
set mylist [2 7 5 Bob [3 0 -2]]
; mylist is now [2 7 5 Bob [3 0 -2]]
set mylist replace-item 2 mylist 10
; mylist is now [2 7 10 Bob [3 0 -2]]
        </pre>
        <p>Команда <a href="Dictionary.html#replace-item">replace-item</a> принимает три параметра. Первый указывает, какой элемент в списке должен быть 
            изменен (нумерация элементов начинается с 0), второй - сам список, третий - новое значение элемента.</p>
        <p>Далее, чтобы добавить элемент, к примеру, число 42 в конец списка, используйте функцию <a href="Dictionary.html#lput">lput</a>. 
            (<a href="Dictionary.html#fput">fput</a> добавляет элемент в начало списка).</p>
        <pre>
set mylist lput 42 mylist
; mylist is now [2 7 10 Bob [3 0 -2] 42]
        </pre>
        <p>Репортер <a href="Dictionary.html#but-first-and-last">but-last</a> (или сокращенно bl) возвращает список, исключая последний элемент.</p>
        <pre>
set mylist but-last mylist
; mylist is now [2 7 10 Bob [3 0 -2]]
        </pre>
        <p>Аналогично для исключения первого элемента можно использовать <a href="Dictionary.html#but-first-and-last">but-first</a>.</p>
        <pre>
set mylist but-first mylist
; mylist is now [7 10 Bob [3 0 -2]]
        </pre>
        <p>Положим, что Вам необходимо изменить третий элемент списка mylist (список [3 0 -2]). Вы можете обратиться к нему, используя 
            <a href="Dictionary.html#item">item</a> 3 mylist:</p>
        <pre>
set mylist (replace-item 3 mylist
                  (replace-item 2 (item 3 mylist) 9))
; mylist is now [7 10 Bob [3 0 9]]
        </pre>

        <p><b>Итерация по списку</b></p>
        <p>Если Вы хотите выполнить какую-либо операцию над каждым элементом списка, используйте <a href="Dictionary.html#foreach">foreach</a> и 
            <a href="Dictionary.html#map">map</a>.</p>
        <p><a href="Dictionary.html#foreach">foreach</a> используется для запуска команды или нескольких команд для каждого элемента списка. 
            Для этого команда принимает на вход сам список и команду или блок команд, например:</p>
        <pre>
foreach [1 2 3] show
=> 1
=> 2
=> 3
foreach [2 4 6]
  [ n -> crt n
    show (word "created " n " turtles") ]
=> created 2 turtles
=> created 4 turtles
=> created 6 turtles
        </pre>
        <p>В этом примере переменная n содержит текущее обрабатываемое значение списка.</p>
        <p>Еще примеры использования foreach:</p>
        <pre>
foreach [1 2 3] [ steps -> ask turtles [ fd steps ] ]
;; turtles move forward 6 patches
foreach [true false true true] [ should-move? -> ask turtles [ if should-move? [ fd 1 ] ] ]
;; turtles move forward 3 patches
        </pre>
        <p><a href="Dictionary.html#map">map</a> аналогичен foreach, за тем исключением, что является репортером и на вход принимает так же блок-репортер:</p>
        <pre>
show map round [1.2 2.2 2.7]
;; prints [1 2 3]
        </pre>
        <p>map возвращает список, содержащий результаты применения reporter к каждому элементу входного списка. В качестве репортера может выступать 
            анонимная процедура с одним входным параметром:</p>
        <pre>
show map [ x -> x < 0 ] [1 -1 3 4 -2 -10]
;; prints [false true false false true true]
show map [ x -> x * x ] [1 2 3]
;; prints [1 4 9]
        </pre>
        <p>Также к командам, обрабатывающим списки, относятся 
            <a href="Dictionary.html#filter">filter</a>, <a href="Dictionary.html#reduce">reduce</a> и <a href="Dictionary.html#sort-by">sort-by</a>.</p>
        <p>Помните, что работать со списками можно не только с помощью этих примитивов, но и в цикле и рекурсивных процедурах.</p>
        <p>Во многих примерах выше в качестве команд использовались Анонимные процедуры. Подробнее о них читайте <a href="#Anonymous-procedures">тут</a>.</p>
        
        <p><b>Переменное число параметров</b></p>
        <p>Некоторые команды и репортеры, использующие списки и строки, могут принимать различное число входных параметров. В этом случае примитив и 
            его входные данные должны быть заключены в круглые скобки:</p>
        <pre>
show list 1 2
=> [1 2]
show (list 1 2 3 4)
=> [1 2 3 4]
show (list)
=> []
        </pre>
        <p>Обратите внимание, что каждый из этих специальных примитивов имеет стандартный вызов, для которого скобки не требуются. Примитивы, которые обладают 
            такой возможностью - это 
            <a href="Dictionary.html#list">list</a>, 
            <a href="Dictionary.html#word">word</a>,
            <a href="Dictionary.html#sentence">sentence</a>,
            <a href="Dictionary.html#map">map</a>,
            <a href="Dictionary.html#foreach">foreach</a>,
            <a href="Dictionary.html#run">run</a>,
            <a href="Dictionary.html#run">runresult</a>.</p>
        
        <p><b>Списки агентов</b></p>
        <p>Ранее мы говорили, что агенты в agentset каждый раз обрабатываются в случайном порядке. Если Вам нужно, 
            чтобы агенты выполняли что-то в определенном порядке, поместите их в список.</p>
        <p>Есть два примитива, которые помогут Вам сделать это: <a href="Dictionary.html#sort">sort</a> и <a href="Dictionary.html#sort-by">sort-by</a>.</p>
        <p>sort и sort-by принимают agentset в качестве входных данных. Результатом всегда является новый список, содержащий те же агенты, что и agentset, 
            но в определенном порядке.</p>
        <p>При использовании sort с множеством черепах, результатом будет список черепах, отсортированных в порядке возрастания переменной who.</p>
        <p>При использовании sort с множеством патчей, в результате получается список патчей, отсортированных слева направо, сверху вниз по их координатам.</p>
        <p>При использовании sort с множеством связей, результатом будет список связей, отсортированный в убывающем порядке по 
            <a href="Dictionary.html#end1">end1</a> и <a href="Dictionary.html#end2">end2</a> (при равенстве для разрешения спора 
            используется порядок определения видов связей).</p>
        <p>Если необходимо расположить агентов по убыванию, используйте <a href="Dictionary.html#reverse">reverse</a>, например, reverse sort turtles.</p>
        <p>Если Вы хотите, чтобы агенты были упорядочены по какому-либо другому критерию, отличному от тех, которые использует sort, следует использовать sort-by:</p>
        <pre>sort-by [ [a b] -> [size] of a < [size] of b ] turtles</pre>
        <p>В примере выше вернется список черепах, отсортированных в порядке возрастания их размера.</p>
        <p>Чтобы получить список агентов в случайном порядке, Вы можете использовать of:</p>
        <pre>[self] of my-agentset</pre>
        
        <p><b>Обращение к списку агентов</b></p>
        <p>Когда список агентов готов, Вы, вероятно, хотите, чтобы каждый агент из списка что-то сделал. Для этого используйте команды foreach и ask:</p>
        <pre>
foreach sort turtles [ the-turtle ->
  ask the-turtle [
    ...
  ]
]
        </pre>
        <p>Это позволит попросить каждую черепаху в порядке возрастания переменной who сделать какое-либо действие.</p>
        <p>Обратите внимание, что Вы не можете использовать ask непосредственно для списка. ask работает только с agentset и отдельными агентами.</p>

        <p><b>Производительность списков</b></p>
        <p>Структура данных, лежащая в основе списков NetLogo, представляет собой сложную древовидную структуру, над которой большинство 
            операций выполняется практически за константное время. Это включает fput, lput, butfirst, butlast, length, item и replace-item.</p>
        <p>Единственным исключением является объединение двух списков (sentence): оно требует обхода и копирования второго списка
            (это может быть исправлено в будущей версии).</p>
        <p>Технически, “почти константное время” на самом деле является логарифмическим, пропорциональным глубине лежащего в основе дерева, но эти деревья имеют 
            большие узлы и сильно ветвятся, поэтому их глубина никогда не превышает нескольких уровней. Это значит, что изменения происходят не
            более чем за несколько шагов. Деревья неизменяемы, но они имеют общую друг для друга структуру, поэтому для создания измененной версии дерева 
            не нужно копировать его целиком.</p>
        <p>Фактически, в качестве структуры данных используется неизменяемый класс Vector из библиотеки Scala collections. Это 32-битные ассоциативные по хэшу деревья, 
            реализованные Тиарком Ромпфом (Tiark Rompf), частично основанные на  работах Фила Бэгвелла (Phil Bagwell) и Рича Хики (Rich Hickey).</p>
    </div>

    <h2 id="Maths">Математика</h2>
    <div class="dict_entry">
        <p>Все числа в NetLogo хранятся в виде чисел с плавающей запятой двойной точности, как определено в стандарте IEEE 754. 
            Это 64-разрядные числа, состоящие из одного бита знака, 11-разрядной экспоненты и 52-разрядной мантиссы. 
            Более подробную информацию смотрите в стандарте IEEE 754.</p>
        <p>“Целое число” в NetLogo - это число, у которого нет дробной части. Между 3 и 3.0 нет разницы - это одно и то же число в NetLogo.</p>
        <p>Целые числа в NetLogo выводятся без “.0”:</p>
        <pre>
show 1.5 + 1.5
observer: 3
        </pre>
        <p>Если число с дробной частью применяется в контексте, где ожидается целое число, дробная часть просто отбрасывается. Так, например, crt 3.5 создает три черепашки; 
            0.5 игнорируется.</p>
        <p>Диапазон целых чисел равен +/-9007199254740992 (2^53, около 9 квадриллионов). Вычисления, превышающие этот диапазон, не вызовут runtime-error, 
            но точность будет потеряна. При использовании очень больших чисел такое округление может привести к неверным результатам:</p>
        <pre>
show 2 ^ 60 + 1 = 2 ^ 60
=> true
        </pre>
        <p>Вычисления с дробными числами также могут привести к неожиданным результатам, поскольку не все дроби могут быть точно представлены в памяти. Например:</p>
        <pre>
show 1 / 6 + 1 / 6 + 1 / 6 + 1 / 6 + 1 / 6 + 1 / 6
=> 0.9999999999999999
show 1 / 9 + 1 / 9 + 1 / 9 + 1 / 9 + 1 / 9 + 1 / 9 + 1 / 9 + 1 / 9 + 1 / 9
=> 1.0000000000000002
        </pre>
        <p>Любая операция, которая приводит к появлению специальных величин "бесконечность" (infinity) или "не число" (not a number), вызовет runtime-error.</p>
        
        <p><b>Научная нотация</b></p>
        <p>Очень большие или очень маленькие числа с плавающей точкой отображаются NetLogo с использованием "научной нотации":</p>
        <pre>
show 0.000000000001
=> 1.0E-12
show 50000000000000000000
=> 5.0E19
        </pre>
        <p>Числа в научной нотации отличаются наличием буквы E. После нее следует степень числа 10, на которое нужно умножить число, стоящее до Е.
             Так, например, 1,0E-12 означает 1,0, умноженное на 10 в степени -12:</p>
        <pre>
show 1.0 * 10 ^ -12
=> 1.0E-12
        </pre>
        <p>Вы также можете использовать научную нотацию в коде NetLogo:</p>
        <pre>
show 3.0E6
=> 3000000
show 8.123456789E6
=> 8123456.789
show 8.123456789E7
=> 8.123456789E7
show 3.0E16
=> 3.0E16
show 8.0E-3
=> 0.0080
show 8.0E-4
=> 8.0E-4
        </pre>
        <p>Примеры показывают, что числа с дробной частью отображаются в научной нотации, если показатель степени меньше -3 или больше 6. Числа за пределами целочисленного 
            диапазона NetLogo (от -9007199254740992 до 9007199254740992; +/-2^53) также всегда отображаются в научной системе счисления:</p>
        <pre>
show 2 ^ 60
=> 1.15292150460684698E18
        </pre>
        <p>При вводе числа буква E может быть как заглавной, так и строчной. При выводе числа NetLogo всегда использует заглавную букву E:</p>
        <pre>
show 4.5e20
=> 4.5E20
        </pre>
        
        <p><b>Точность чисел с плавающей точкой</b></p>
        <p>Поскольку на числа в NetLogo распространяются ограничения, связанные с представлением чисел с плавающей точкой в двоичном формате, 
            вероятно возникновение несколько неточных ответов. Например:</p>
        <pre>
show 0.1 + 0.1 + 0.1
=> 0.30000000000000004
show cos 90
=> 6.123233995736766E-17
        </pre>
        <p>Это неотъемлемая проблема двоичной арифметики дробных чисел; она возникает во всех языках программирования, использующих числа с плавающей точкой.</p>
        <p>Если вы имеете дело с величинами фиксированной точности, например с долларами и центами, то удобным может быть использование внутри модели только 
            целых чисел (центов). Для получения результата в долларах просто поделите значение центов на 100.</p>
        <p>Если все же необходимо использовать числа с плавающей точкой, то в некоторых ситуациях вам может потребоваться заменить простой тест на равенство 
            (if x = 1 [ ... ]) на тест, учитывающий погрешность (if abs (x - 1) < 0,0001 [ ... ]).</p>
        <p>Для округления чисел может быть удобно использовать примитив <a href="Dictionary.html#precision">precision</a>. Поля NetLogo, отображающие числа, 
            округляют числа до настраиваемого числа знаков после запятой.</p>
    </div>

    <h2 id="Random-Numbers">Случайные числа</h2>
    <div class="dict_entry">
        <p>Случайные числа, используемые NetLogo, являются "псевдослучайными" (что вполне типично для программирования). Это значит, что они лишь кажутся случайными, 
            но на самом деле генерируются детерминированным процессом. “"Детерминированный" означает, что Вы будете получать один и тот же результат, если начнете генерацию
            с одного и того же "зерна". Что такое "зерно" будет сказано позже.</p>
        <p>В контексте научного моделирования псевдослучайные числа являются крайне удобным инструментом. Важно, чтобы научный эксперимент был воспроизводимым – чтобы каждый мог 
            провести его сам и получить тот же результат, что и Вы. Поскольку NetLogo использует псевдослучайные числа, "эксперименты", которые Вы проводите, могут быть 
            воспроизведены другими пользователями.</p>
        <p>Генератор случайных чисел NetLogo можно запустить с определенным начальным значением - зерном, которое должно быть целым числом в диапазоне от -2147483648 до 
            2147483647. После того, как генератор был инициализирован зерном с помощью команды <a href="Dictionary.html#random-seed">random-seed</a>, 
            он всегда генерирует одну и ту же последовательность случайных чисел (для данного зерна). Например, если Вы запустите следующие команды:</p>
        <pre>
random-seed 137
show random 100
show random 100
show random 100
        </pre>
        <p>вы всегда будете получать числа 79, 89 и 61 именно в таком порядке.</p>
        <p>Обратите внимание, что Вы будет получать те же числа только если используете ту же версию NetLogo. Иногда при создании новой версии NetLogo, мы меняем 
            генератор случайных чисел (в настоящее время мы используем генератор, известный как Mersenne Twister).</p>
        <p>Чтобы создать число, подходящее как зерно генератора случайных чисел, используйте <a href="Dictionary.html#new-seed">new-seed</a>. Команда 
            возвращает зерно, равномерно распределенное по области возможных значений зерна, на основе текущей даты и времени. 
            Она никогда не возвращает одно и то же зерно дважды подряд.</p>
        <p><b>Пример кода:</b> Random Seed Example.</p>
        <p>Если вы не зададите зерно, NetLogo самостоятельно установит для него значение, основанное на текущей дате и времени. При этом узнать, какое зерно 
            было установлено, возможности нет, поэтому, если Вы хотите, чтобы ваша модель была воспроизводимой, необходимо задать зерно самостоятельно.</p>
        <p>Примитивы NetLogo со словом "random" в названии (random, random-float и т.д.) - не единственные, которые используют псевдослучайные числа. 
            Многие другие команды делают случайный выбор, например <a href="Dictionary.html#one-of">one-of</a> и <a href="Dictionary.html#n-of">n-of</a>, 
            <a href="Dictionary.html#sprout">sprout</a>, <a href="Dictionary.html#downhill">downhill</a>. Все они используют генератор случайных чисел и потому
            их действия могут быть воспроизведены.</p>
        <p>Помимо равномерно распределенных случайных числе NetLogo так же предлагает другие распределения. См. 
            <a href="Dictionary.html#random-reporters">random-normal</a>, 
            <a href="Dictionary.html#random-reporters">random-poisson</a>, 
            <a href="Dictionary.html#random-reporters">random-exponential</a>, 
            <a href="Dictionary.html#random-reporters">random-gamma</a>.
        </p>

        <h3>Вспомогательные генераторы</h3>
        <p>Код, запускаемый кнопками или из Командного Центра, использует основной генератор случайных чисел.</p>
        <p>Код в мониторах (элемент интерфейса, отображающий значение переменной или рассчитываемое значение), использующий случайные числа, рассчитывает их на основе 
            собственного, вспомогательного генератора, чтобы генерация значений не влияла на последовательность основного генератора. То же справедливо для слайдеров.</p>
        
        <h3>Локальная случайность</h3>
        <p>Возможно, Вам требуется явно указать, что какой-либо фрагмент кода не влияет на состояние основного генератора случайных чисел. 
            Для этой цели предусмотрена команда <a href="Dictionary.html#with-local-randomness">with-local-randomness</a>.</p>
        
        <h3>Сохранение зерна</h3>
        <p>Если вы хотите знать, какое случайное начальное значение использовалось при запуске модели, Вы можете добавить следующий код для его отслеживания. 
            Тогда, если будут обнаружены необычное поведение или периодическая ошибка, вы сможете воспроизвести возникшую ситуацию, 
            установив использовавшееся начальное значение повторно.</p>
        <p>Добавьте глобальную переменную starting-seed, затем используйте <a href="Dictionary.html#new-seed">new-seed</a>, чтобы присвоить ей значение.
            Затем передайте это значение команде <a href="Dictionary.html#random-seed">random-seed</a>.</p>
        <pre>
globals [starting-seed]

to setup
  clear-all
  set starting-seed new-seed
  random-seed starting-seed
  ; ... rest of normal setup code
end

to go
  ; ... the rest of normal model code will use the random seed set in `setup`
end
        </pre>
        <p>Затем Вы можете добавить монитор для starting-seed или просто вывести его в командный центр. Если Вы используете BehaviorSpace для проведения экспериментов, 
            Вы также можете выводить значение starting-seed, чтобы иметь возможность позже воспроизвести запуск.</p>
    </div>

    <h2 id="Turtle-shapes">Формы черепах</h2>
    <div class="dict_entry">
        <p>Формы черепах в NetLogo являются векторными - они состоят из основных геометрических фигур: квадратов, кругов и линий. Векторные фигуры полностью масштабируемы 
            и могут поворачиваться. NetLogo кэширует растровые изображения векторных фигур размером 1, 1.5 и 2 для ускорения работы.</p>
        <p>Форма черепахи хранится в переменной <a href="Dictionary.html#shape">shape</a> и может быть задана с помощью команды <a href="Dictionary.html#set">set</a>.</p>
        <p>Новым черепахам устанавливается форма "по умолчанию". Примитив <a href="Dictionary.html#set-default-shape">set-default-shape</a> 
            позволяет установить форму по умолчанию на другую, а так же задать форму по умолчанию для отдельного вида черепах.</p>
        <p>Примитив <a href="Dictionary.html#shapes">shapes</a> возвращает список доступных в данный момент форм черепах. 
            Вы можете использовать это, например, чтобы установить черепахе произвольную форму:</p>
        <pre>ask turtles [ set shape one-of shapes ]</pre>
        <p>Используйте редактор форм черепах (Turtle Shapes Editor) для создания собственных форм, добавления форм из готовой библиотеки или для импорта форм между моделями. 
            Дополнительные сведения о редакторе <a href="https://ccl.northwestern.edu/netlogo/docs/shapes.html">тут</a>.</p>
        <p>Толщиной линий, используемых для отрисовки векторных фигур, можно управлять с помощью примитива <a href="Dictionary.html#__set-line-thickness">__set-line-thickness</a>.</p>
        <p><b>Пример кода:</b> Breeds and Shapes Example, Shape Animation Example.</p>
    </div>

    <h2 id="Link-shapes">Формы связей</h2>
    <div class="dict_entry">   
        <p>Формы связей похожи на формы черепах, только для их создания и редактирования используется редактор форм связей (Link Shapes Editor).
            Фигуры связей состоят из линий (от 0 до 3), которые могут иметь различный вид и указатель направленности связи. Указатель строится из тех же элементов, 
            что и фигуры черепах. У связей также есть переменная <a href="Dictionary.html#shape">shape</a>, и Вы также можете изменить ее, чтобы установить связи определенную
            форму. Новым связям присваивается форма по умолчанию ("default"), для установки формы по умолчанию можно использовать 
            <a href="Dictionary.html#set-default-shape">set-default-shape</a></p>
        <p>Репортер <a href="Dictionary.html#link-shapes">link-shapes</a> возвращает все доступные в текущей модели формы связей.</p>
        <p>Толщиной линий можно управлять, изменяя переменную <a href="Dictionary.html#thickness">thickness</a>.</p>
    </div>

    <h2 id="View-update">Обновление экрана</h2>
    <div class="dict_entry">
        <p>Экран позволяет наблюдать за агентами и их взаимодействием. В каждый момент на экране отображается текущее состояние мира. Агенты совершают те или иные действия,
            их состояние меняется, меняется и то, что выводится на экран. Эти изменения называются обновлением экрана.</p> <!--ВОПРОС (мне этот параграф кажется очевидным, я бы его убрал)-->
        <p>Текущий раздел посвящен тому, как можно влиять на процесс обновления экрана.</p>
        <p>NetLogo предлагает два режима обновления: непрерывное и основанное на тиках. Вы можете переключаться между этими двумя режимами, 
            используя меню в верхней части вкладки "Интерфейс".</p>
        <p>При запуске NetLogo или создании новой модели по умолчанию используется непрерывное обновление, однако почти каждая модель в Библиотеке Моделей 
            использует обновления на основе тиков.</p>
        <p>Непрерывное обновление более простое; обновления на основе тиков дают больше контроля над тем, когда и как часто происходят обновления.</p>
        <p>Важно, когда именно происходит обновление, потому что от этого зависит то, что Вы наблюдаете на экране. Если обновление происходит в неподходящий 
            момент, можно увидеть, например, несоответствующее ожиданию поведение.</p>
        <p>Также важно, как часто происходят обновления, поскольку обновление экрана требует времени. Чем больше времени NetLogo тратит на обновление экрана, 
            тем медленнее будет работать модель.</p>
        
        <h3>Непрерывное обновление</h3>
        <p>В режиме непрерывного обновления NetLogo обновляет экран определенное количество раз за единицу времени – по умолчанию это 30 раз в секунду (при этом
            ожидается, что ползунок скорости выполнения находится в среднем положении).</p>
        <p>При уменьшении скорости, NetLogo будет обновлять экран более 30 раз в секунду, что значительно замедлит работу модели. При увеличении скорости 
            NetLogo будет обновлять экран менее 30 раз в секунду.</p>
        <p>Если необходимо временно отключить обновление, воспользуйтесь командой <a href="Dictionary.html#no-display">no-display</a>. Команда 
            <a href="Dictionary.html#display">display</a> возобновляет обновления. Помимо этого она позволяет вызвать принудительное обновление 
            (если только пользователь не изменяет скорость модели в данный момент).</p>
        
        <h3>Обновления, основанные на тиках</h3>
        <p>Как описывалось ранее в разделе <a href="#Tick-counter">Счетчик тиков</a>, в большом количестве моделей время идет дискретными шагами, которые называются "тики".
            Обновление на основе тиков по умолчанию происходит один раз за тик, между тиками.</p>
        <p>Если Вам нужны дополнительные обновления экрана, Вы можете принудительно выполнить обновление с помощью команды <a href="Dictionary.html#display">display</a> 
            (обновление может быть пропущено, если пользователь ускоряет модель с помощью ползунка скорости).</p>
        <p>Вам не обязательно использовать счетчик тиков, чтобы использовать обновления на их основе. Если счетчик тиков не изменяется, экран будет обновляться только при
            использовании команды display.</p>
        <p>Если Вы установите высокую скорость модели, NetLogo будет пропускать обновления (для повышения скорости). Уменьшение скорости не приводит к дополнительным 
            обновлениям; наоборот, NetLogo приостанавливает работу после каждого обновления. Чем медленнее настройка, тем больше эта пауза.</p>
        <p>Даже при обновлениях на основе тиков экран обновляется всякий раз, когда в интерфейсе "отжимается" кнопка (как once, так и forever), и когда команда, введенная 
            в Командном Центре, завершает работу. Таким образом, нет необходимости добавлять команду display к кнопкам once, которые не увеличивают счетчик тиков.
            Для многих forever-кнопок, которые не увеличивают счетчик тиков, требуется использование display. Forever-кнопки, которые позволяют пользователю рисовать, 
            используют display, чтобы пользователь мог видеть, что он рисует, даже если счетчик тиков при этом не увеличивается.</p>
        <p><b>Пример Кода</b>: Life в разделе Sample Models/Computer Science/Cellular Automata/</p>

        <h3>Выбор режима отрисовки</h3>
        <p>Преимущества обновлений на основе тиков по сравнению с непрерывным обновлением:</p>
        <ul>
            <li>Стабильное и предсказуемое поведение обновлений, которое не меняется от устройства к устройству или от запуска к запуску.</li>
            <li>Непрерывное обновление может сбить с толку пользователя модели, позволяя ему видеть состояния модели, которые он не должен видеть.</li>
            <li>Поскольку кнопки setup не увеличивают счетчик тактов, изменение скорости не влияет на них; обычно это желаемое поведение.</li>
        </ul>
        <p>Почти все модели нашей Библиотеки Моделей используют обновления на основе тиков.</p>
        <p>Непрерывные обновления полезны для тех немногих моделей, в которых выполнение не разделено на короткие, дискретные этапы. Как пример - модель Termites
            (а также обратим внимание на модель State Machine example - она показывает, как можно переписать модель Termites на основе тиков).</p>
        <p>Даже для моделей, которые обычно используют обновления на основе тиков, может быть полезным временно переключиться на непрерывные обновления в целях отладки.
            Наблюдение за тем, что происходит в течение тика, вместо того, чтобы видеть только конечный результат тика, может помочь в устранении неполадок.
            После перехода на непрерывное обновление используйте ползунок скорости, чтобы замедлить работу модели до того состояния, когда ваши агенты перемещаются 
            по одному за раз. Не забудьте вернуться к обновлениям на основе тиков, когда закончите, так как выбранный режим обновления сохраняется вместе с моделью.</p>
        <p>Режим обновления экрана также влияет на скорость работы модели. Обновление экрана требует времени; часто обеспечение выполнения строго одного обновления за 
            такт (в режиме обновлений на основе тиков) ускоряет работу вашей модели. С другой стороны, если обработать тик оказывается быстрее, чем отрисовать кадр экрана,
            то непрерывный режим будет более производительным. Большинство моделей работают быстрее при обновлениях на основе тиков; пример модели, которая работает 
            быстрее при непрерывных обновлениях - "Heroes and Cowards".</p>
            
        <h3>Частота обновления кадров</h3>
        <p>Частоту обновления кадров можно установить в меню "Установки" (Settings), стандартное значение - 30 кадров в секунду.</p>
        <p>Частота кадров влияет на оба режима обновления экрана.</p>
        <p>При непрерывном обновлении этот параметр напрямую определяет частоту обновлений.</p>
        <p>При использовании обновлений на основе тиков этот параметр ограничивает число обновлений в секунду. Если частота кадров равна 30, NetLogo гарантирует, 
            что модель никогда не будет работать быстрее, чем это значение (с учетом, что ползунок скорости установлен в положение по умолчанию). 
            Если для вычисления и отображения какого-либо кадра требуется менее 1/30 секунды, NetLogo сделает паузу и подождет, пока не пройдет 1/30 секунды, прежде 
            чем продолжить работу.</p>
        <p>Настройка частоты кадров позволяет определить ту скорость, которую Вы считаете нормальной для вашей модели. Затем Вы или пользователь вашей модели можете 
            использовать ползунок скорости, чтобы временно увеличить или уменьшить эту скорость.</p>
    </div>   
    
    <h2 id="Plots">Графики</h2>
    <div class="dict-entry">
        <p>NetLogo позволяет создавать различные графики для Ваших моделей.</p>
        <p>Перед построением графиков необходимо создать один или несколько графиков на вкладке Интерфейс. Дополнительные сведения о создании графиков через интерфейс 
            см. <a href="https://ccl.northwestern.edu/netlogo/docs/interfacetab.html#plots">тут</a>.</p>
        
        <h3>Построение точек</h3>
        <p>Две основные команды для построения графиков - это <a href="Dictionary.html#plot">plot</a> и <a href="Dictionary.html#plotxy">plotxy</a>.</p>
        <p>При использовании plot нужно указать только значение y, которое Вы хотите отобразить. Значение x автоматически будет равно 0 для первой точки, 
            1 для второй и так далее (это действительно только том случае, если интервал кисти равен 1; этот интервал можно изменять).</p>
        <p>Команда plot особенно удобна, когда Вы хотите, чтобы Ваша модель отображала новую точку на каждом тике:</p>
        <pre>plot count turtles</pre>
        <p>Если нужно использовать значения x и y для точки, используйте plotxy. В этом примере предполагается, что существует глобальная переменная time:</p>
        <pre>plotxy time count-turtles</pre>

        <h3>Команды для работы с графиками</h3>
        <p>У каждого графика и его кистей есть код начальной настройки (setup) и код обновления (update) (обычно содержащие plot или plotxy). Эти команды запускаются 
            автоматически другими командами в NetLogo.</p>
        <p>Команды setup для графика и кисти запускаются при выполнении <a href="Dictionary.html#reset-ticks">reset-ticks</a> или 
            <a href="Dictionary.html#setup-plots">setup-plots</a>. Если при этом в setup у графика используется <a href="Dictionary.html#stop">stop</a>, 
            то setup для кисти выполняться не будет.</p>
        <p>Команды update для графика и кисти запускаются при выполнении <a href="Dictionary.html#reset-ticks">reset-ticks</a>, <a href="Dictionary.html#tick">tick</a> или 
            <a href="Dictionary.html#update-plots">update-plots</a>. Если при этом в update у графика используется <a href="Dictionary.html#stop">stop</a>, 
            то update для кисти выполняться не будет.</p>
        <ul>
            <li><a href="Dictionary.html#setup-plots">setup-plots</a> выполняет команды setup для каждого графика. Затем для каждой кисти графиков будет выполнен свой setup код.</li>
            <li>Команда <a href="Dictionary.html#update-plots">update-plots</a> аналогична setup-plots, но вызывает функцию update, а не setup.</li>
            <li><a href="Dictionary.html#tick">tick</a> действует так же, как update-plots, за тем исключением, что она также увеличивает счетчик тиков перед 
                выполнением команд.</li>
            <li><a href="Dictionary.html#reset-ticks">reset-ticks</a> сначала сбрасывает счетчик тиков, а затем выполняет setup-plots, за которой следует update-plots.</li>
        </ul>
        <p>Типичная модель будет использовать reset-ticks и tick так:</p>
        <pre>
to setup
  clear-all
  ...
  reset-ticks
end

to go
  ...
  tick
end
        </pre>
        <p>Обратите внимание, что в этом примере мы обновляем график как в setup, так в go. Это сделано для того, чтобы график отображал начальное состояние системы. 
            Также обратите внимание на то, что обновление графика в процедуре go происходит в ее конце, а не в начале. Так график остается актуальным в момент паузы.</p>
        <p>Модели, которые используют непрерывное обновление, вместо tick и reset-ticks должны использовать setup-plots и update-plots.</p>
        <p><b>Пример кода:</b> Plotting Example.</p>

        <h3>Виды графиков</h3>
        <p>По умолчанию кисти графиков установлены в режим линии, так что точки, которые Вы строите, соединяются линией.</p>
        <p>Если Вы хотите переместить кисть, при этом не строя линий, Вы можете использовать команду <a href="Dictionary.html#plot-pen-switch-status">plot-pen-up</a> (с англ. 
            поднять перо). После ее выполнения команды plot и plotxy перемещают перо, но ничего не рисуют. Чтобы опустить перо обратно используйте команду 
            <a href="Dictionary.html#plot-pen-switch-status">plot-pen-down</a>.</p>
        <p>Если вы хотите вместо линий рисовать точки или столбцы, необходимо изменить "режим" кисти. Доступны три режима: линии, столбцы и точки. 
            Режим по умолчанию - линии.</p>
        <p>Обычно режим кисти устанавливается при создании графика. Также можно временно изменить режим работы кисти, используя команду 
            <a href="Dictionary.html#set-plot-pen-mode">set-plot-pen-mode</a>. Эта команда принимает число режима в качестве параметра: 0 для линий, 
            1 для столбов, 2 для точек.</p>
    
        <h3>Гистограммы</h3>
        <p>Гистограмма - это особый вид графика, который показывает, как часто определенные значения или значения в определенных диапазонах встречаются в заданном множестве.</p>    
        <p>Предположим, что у черепах в Вашей модели есть переменная age, хранящая возраст черепахи. Вы можете создать гистограмму распределения возрастов 
            среди ваших черепах с помощью команды <a href="Dictionary.html#histogram">histogram</a>:</p>
        <pre>histogram [age] of turtles</pre>
        <p>Числа, которые вы хотите использовать для построения гистограммы, не обязательно должны быть взяты из agentset; это может быть любой список чисел.</p>
        <p>Обратите внимание, что использование команды histogram не приводит к автоматическому переключению текущей кисти в режим столбцов. Если Вы хотите получить 
            столбчатую диаграмму, необходимо самостоятельно установить кисти данный режим (как мы говорили ранее, Вы можете сделать это 
            в окне редактирования графика).</p>
        <p>Для гистограмм, как и для других графиков, можно настроить автоматическое масштабирование. Однако в случае гистограмм автоматический масштаб не изменяет 
            разрешение горизонтальной оси. Чтобы задать диапазон программно, вы можете использовать примитив <a href="Dictionary.html#set-plot-range">set-plot-x-range</a>.</p>
        <p>Ширина диапазонов на гистограмме определяется отдельным параметром кисти - интервалом. Вы можете задать интервал кисти в окне редактирования графика. 
            Вы также можете временно изменить интервал с помощью команды <a href="Dictionary.html#set-plot-pen-interval">set-plot-pen-interval</a> или 
            <a href="Dictionary.html#set-histogram-num-bars">set-histogram-num-bars</a>. При использовании последней NetLogo установит интервал самостоятельно, 
            чтобы он соответствовал указанному количеству столбцов в текущем масштабе оси х.</p>
        <p><b>Пример кода:</b> Histogram Example</p>

        <h3>Очистка и сброс графиков</h3>
        <p>Вы можете очистить текущий график командой <a href="Dictionary.html#clear-plot">clear-plot</a> или очистить все графики модели командой 
            <a href="Dictionary.html#clear-all-plots">clear-all-plots</a>. Команда <a href="Dictionary.html#clear-all">clear-all</a> также очищает все графики, 
            в дополнение ко всему остальному.</p>
        <p>Если Вы хотите удалить только те точки, которые были нарисованы определенной кистью, используйте команду <a href="Dictionary.html#plot-pen-reset">plot-pen-reset</a>.</p>
        <p>При очистке графика или сбросе пера происходит не только удаление нанесенных точек: также восстанавливаются настройки графика/пера по умолчанию, которые были указаны 
            в окне редактирования графика. Поэтому действие таких команд, как <a href="Dictionary.html#set-plot-background-color">set-plot-background-color</a>, 
            <a href="Dictionary.html#set-plot-range">set-plot-x-range</a> и <a href="Dictionary.html#set-plot-pen-color">set-plot-pen-color</a>, 
            носит лишь временный характер.</p>
            
        <h3>Пределы осей и автоматическое масштабирование</h3>
        <p>Пределы осей x и y графика по умолчанию являются фиксированными числами, но их можно изменить во время выполнения процедуры setup или 
            в течение выполнения модели.</p>
        <p>Чтобы изменить пределы осей используйте <a href="Dictionary.html#set-plot-range">set-plot-x-range</a> и 
            <a href="Dictionary.html#set-plot-range">set-plot-y-range</a>. Помимо этого, вы можете включить автоматическое масштабирование. 
            В любом случае, в момент очистки графика, пределы вернутся к значениям по умолчанию.</p>
        <p>функция автоматического масштабирования включена у всех графиков NetLogo по умолчанию. Это значит, что если модель попытается построить точку, которая 
            находится за пределами текущего отображаемого диапазона, масштаб графика увеличится по одной или обеим осям так, чтобы новая точка стала видна. 
            Учтите, что гистограммы не масштабируются по горизонтали.</p>
        <p>Автоматическое увеличение пределов осей происходит с запасом: 25% при увеличении по горизонтали и 10% при увеличении по вертикали. Это сделано с расчетом на то,
            что новые точки будут находиться рядом и график не придется обновлять каждый раз при добавлении новой точки.</p>
        <p>Если Вы хотите отключить функцию автомасштаба, снимите флажок в окне редактирования графика. В настоящее время невозможно использовать эту функцию 
            только для одной оси - она всегда применяется к обеим осям.</p>

        <h3>Легенда</h3>
        <p>Вы можете отобразить легенду графика, установив флажок "Show Legend" в окне редактирования графика. Если Вы не хотите, чтобы определенная кисть отображалась в 
            легенде, Вы можете указать это в расширенных настройках кисти (расширенные настройки можно открыть, нажав на "Карандаш" в таблице таблице перьев в 
            окне редактирования графика).</p>
        
        <h3>Временные кисти</h3>
        <p>Большинство графиков используют фиксированное число кистей. Однако может быть, что Вам потребуется менять число кистей в зависимости от каких-либо условий. 
            В таком случае Вы можете создать “временные” кисти. Эти кисти называются “временными”, потому что они исчезают, когда график очищается 
            (с помощью команд clear-plot, clear-all-plots, clear-all).</p>
        <p>Чтобы создать временную кисть, используйте команду <a href="Dictionary.html#create-temporary-plot-pen">create-temporary-plot-pen</a>. Как правило, это делается на 
            вкладке "Код", но также можно использовать эту команду в процедурах setup и update графика.</p>
        <p>По умолчанию новая кисть опущена, имеет черный цвет, интервал равен 1 и ее режим - линии. Вы можете изменить параметры кисти с помощью примитивов - их список приведен
            в разделе "Построение графиков" в Словаре NetLogo.</p>
        <p>Прежде чем использовать данное перо необходимо использовать команды <a href="Dictionary.html#set-current-plot">set-current-plot</a> и 
            <a href="Dictionary.html#set-current-plot-pen">set-current-plot-pen</a>. Они описаны в следующем разделе.</p>
        
        <h3>set-current-plot и set-current-plot-pen</h3>
        <p>До NetLogo версии 5 невозможно поместить команды работы с графиком в сам график, весь код построения размещался на вкладке "Код". 
            Для обеспечения обратной совместимости и для временных кистей это по-прежнему актуально. Модели, запускаемые в предыдущих версиях NetLogo 
            (и те, которые используют временные кисти), должны явно указывать, какой график является текущим, 
            с помощью команды <a href="Dictionary.html#set-current-plot">set-current-plot</a>, и какое перо является текущим, с помощью команды 
            <a href="Dictionary.html#set-current-plot-pen">set-current-plot-pen</a>.</p>
        <p>Чтобы задать текущий график, используйте команду set-current-plot, заключив название графика в двойные кавычки:</p>
        <pre>set-current-plot "Distance vs. Time"</pre>
        <p>Название графика должно быть точно таким, как Вы ввели его при создании. Обратите внимание, что если Вы измените название графика, Вам также придется 
            изменить его название во всех вызовах set-current-plot.</p>
        <p>Если у графика существует несколько кистей, Вы можете вручную указать, какую кисть Вы хотите использовать. По умолчанию график будет использовать первую кисть.
            Чтобы изменить перо, используйте <a href="Dictionary.html#set-current-plot-pen">set-current-plot-pen</a> (при этом название пера нужно заключить в двойные 
            кавычки):</p>
        <pre>set-current-plot-pen "distance"</pre>
        <p>После задания графика и кисти можете использовать все знакомые команды для работы с графиком.</p>
        <p>Более старые модели с графиками обычно имели отдельную процедуру для построения графика do-plotting, которая выглядела примерно так:</p>
        <pre>
to do-plotting
  set-current-plot "populations"
  set-current-plot-pen "sheep"
  plot count sheep
  set-current-plot-pen "wolves"
  plot count wolves

  set-current-plot "next plot"
  ...
end
        </pre>
        <p>Повторимся - начиная с NetLogo версии 5 в использовании set-current-plot и set-current-plot-pen нет необходимости, если только Вы 
            не используете временные перья.</p>
        
        <h3>Завершение</h3>
        <p>В данном разделе описаны не все аспекты построения графиков в NetLogo. Информацию о командах, связанных с построением графиков, смотрите в разделе 
            "Построение графиков" Словаря NetLogo.</p>
        <p>Большое число моделей из Библиотеки иллюстрирует различные продвинутые методы построения графиков.</p>
        <p><b>Пример кода:</b> Plot Axis Example, Plot Smoothing Example, Rolling Plot Example.</p>
    </div>

    <h2 id="Strings">Строки</h2>
    <div class="dict-entry">
        <p>Строки могут содержать любые символы Юникода.</p>
        <p>Чтобы ввести константную строку в NetLogo, заключите ее в двойные кавычки.</p>
        <p>Пустая строка записывается путем помещения ничего в кавычки, например: "".</p>
        <p>Большинство примитивов списков также работают со строками:</p>
        <pre>but-first "string" => "tring"
but-last "string" => "strin"
empty? "" => true
empty? "string" => false
first "string" => "s"
item 2 "string" => "r"
last "string" => "g"
length "string" => 6
member? "s" "string" => true
member? "rin" "string" => true
member? "ron" "string" => false
position "s" "string" => 0
position "rin" "string" => 2
position "ron" "string" => false
remove "r" "string" => "sting"
remove "s" "strings" => "tring"
replace-item 3 "string" "o" => "strong"
reverse "string" => "gnirts"</pre>
        <p>Некоторые примитивы специфичны для строк, например <a href="Dictionary.html#is-of-type">is-string?</a>, <a href="Dictionary.html#subliststring">substring</a> и <a href="Dictionary.html#word">word</a>:</p>
        <pre>is-string? "string" => true
is-string? 37 => false
substring "string" 2 5 => "rin"
word "tur" "tle" => "turtle"</pre>
        <p>Строки можно сравнивать с помощью операторов =, !=, <, >, <= и >=.</p>
        <p>Если вам нужно встроить в строку специальный символ, используйте следующие управляющие последовательности:</p>
        <ul>
            <li>\n = перенос строки</li>
            <li>\t = табуляция</li>
            <li>\" = двойная кавычка</li>
            <li>\\ = обратная косая черта</li>
        </ul>
    </div>

    <h2 id="Output">Вывод</h2>
    <div class="dict-entry">
        <p>Этот раздел посвящен выводу на экран. Вывод на экран также можно позже сохранить в файл с помощью <a href="Dictionary.html#export-cmds">export-output</a> команды. Если вам нужен более гибкий метод записи данных во внешние файлы, см. следующий раздел <a href="#File-I/O">Файловый ввод/вывод</a></p>
        <p>Основными командами для вывода на экран в NetLogo являются <a href="Dictionary.html#print">print</a>, <a href="Dictionary.html#show">show</a>, <a href="Dictionary.html#type">type</a> и <a href="Dictionary.html#write">write</a>. Эти команды отправляют свои выходные данные в Командный центр.</p>
        <p>Полную информацию об этих четырех командах см. в их записях в словаре NetLogo. Вот как они обычно используются:</p>
        <ul>
            <li><a href="Dictionary.html#print">print</a> полезен в большинстве ситуаций.</li>
            <li><a href="Dictionary.html#show">show</a> позволяет увидеть, какой агент что печатает.</li>
            <li><a href="Dictionary.html#type">type</a> позволяет печатать несколько объектов в одной строке.</li>
            <li><a href="Dictionary.html#write">write</a> позволяет печатать значения в формате, который можно прочитать с помощью <a href="Dictionary.html#file-read">file-read</a>.</li>
        </ul>
        <p>Модель NetLogo может дополнительно иметь «область вывода» на вкладке «Интерфейс», отдельную от Командного центра. Чтобы отправить выходные данные туда вместо Командного центра, используйте команды <a href="Dictionary.html#output-cmds">output-print</a>, <a href="Dictionary.html#output-cmds">output-show</a>, <a href="Dictionary.html#output-cmds">output-type</a> и <a href="Dictionary.html#output-cmds">output-write</a>.</p>
        <p>Область вывода можно очистить командой <a href="Dictionary.html#clear-output">clear-output</a> и сохранить в файл с расширением <a href="Dictionary.html#export-cmds">export-output</a>. Содержимое области вывода будет сохранено командой <a href="Dictionary.html#export-cmds">export-world</a>. Команда <a href="Dictionary.html#import-world">import-world</a> очистит область вывода и установит для ее содержимого значение из импортированного файла привязки. Следует отметить, что большие объемы данных, отправляемые в область вывода, могут увеличить размер экспортируемых миров.</p>
        <p>Если вы используете <a href="Dictionary.html#output-cmds">output-print</a>, <a href="Dictionary.html#output-cmds">output-show</a>, <a href="Dictionary.html#output-cmds">output-type</a>, <a href="Dictionary.html#output-cmds">output-write</a>, <a href="Dictionary.html#clear-output">clear-output</a> или <a href="Dictionary.html#export-cmds">export-output</a> в модели, которая не имеет отдельной области вывода, команды применяются к части вывода Командного центра.</p>
    </div>
    <div class="dict-entry">
        <h3>Чем отличаются примитивы вывода</h3>
        <p>Эта информация представляет собой краткий справочник для более опытных пользователей.</p>
        <p>Примитивы print, show, type и write различаются по следующим аспектам:</p>
        <ul>
            <li>Какие типы значений принимает примитив?</li>
            <li>Выполняет ли примитив перенос каретки на новую строку?</li>
            <li>Выводятся ли строки с кавычками?</li>
            <li>Выводит ли примитив агента, который его напечатал?</li>
        </ul>
        <p>В следующей таблице суммировано поведение каждого примитива.</p>
        <table>
            <tr>
                <th>Примитив</th>
                <th>Допустимые значения</th>
                <th>Перенос строки</th>
                <th>Строки в кавычках</th>
                <th>Вывод self</th>
            </tr>
            <tr style="background: #ffffff;">
                <td><a href="Dictionary.html#print">print</a></td>
                <td>любое значение NetLogo</td>
                <td>да</td>
                <td>нет</td>
                <td>нет</td>
            </tr>
            <tr style="background: #ffffff;">
                <td><a href="Dictionary.html#show">show</a></td>
                <td>любое значение NetLogo</td>
                <td>да</td>
                <td>да</td>
                <td>да</td>
            </tr>
            <tr style="background: #ffffff;">
                <td><a href="Dictionary.html#type">type</a></td>
                <td>любое значение NetLogo</td>
                <td>нет</td>
                <td>нет</td>
                <td>нет</td>
            </tr>
            <tr style="background: #ffffff;">
                <td><a href="Dictionary.html#write">write</a></td>
                <td>логические значения, числа, строки и списки, содержащие только эти типы</td>
                <td>нет</td>
                <td>да</td>
                <td>нет</td>
            </tr>
        </table>
    </div>

    <h2 id="File-I/O">Файловый ввод/вывод</h2>
    <div class="dict-entry">
        <p>В NetLogo есть набор примитивов, которые дают вам возможность взаимодействовать с внешними файлами. Все они начинаются с префикса file- .</p>
        <p>При работе с файлами существует два основных режима: чтение и запись. Разница заключается в направлении потока данных. Когда вы считываете информацию из файла, данные, хранящиеся в файле, передаются в вашу модель. С другой стороны, запись позволяет данным передаваться из вашей модели в файл.</p>
        <p>При работе с файлами всегда начинайте с использования примитива <a href="Dictionary.html#file-open">file-open</a>. Он задает, с каким файлом вы будете взаимодействовать. Ни один из других примитивов не будет работать, пока вы не откроете файл с помощью <a href="Dictionary.html#file-open">file-open</a>.</p>
        <p>Следующий файловый примитив, который вы должны использовать, определяет, в каком режиме будет находиться файл до его закрытия (чтение или запись). Чтобы переключить режимы, закройте и снова откройте файл.</p>
        <p>Примитивы чтения включают <a href="Dictionary.html#file-read">file-read</a>, <a href="Dictionary.html#file-read-line">file-read-line</a>, <a href="Dictionary.html#file-read-characters">file-read-characters</a> и <a href="Dictionary.html#file-at-end?">file-at-end?</a>. Обратите внимание: файл должен уже существовать, прежде чем вы сможете открыть его для чтения.</p>
        <p>Примитивы для записи аналогичны примитивам, которые печатают данные в Командном центре, за исключением того, что выходные данные сохраняются в файл. К ним относятся <a href="Dictionary.html#file-print">file-print</a>, <a href="Dictionary.html#file-show">file-show</a>, <a href="Dictionary.html#file-type">file-type</a>, и <a href="Dictionary.html#file-write">file-write</a>. Обратите внимание, что вы никогда не сможете «перезаписать» данные. Другими словами, если вы попытаетесь записать в файл существующие данные, все новые данные будут добавлены в конец файла. (Если вы хотите перезаписать файл, используйте <a href="Dictionary.html#file-delete">file-delete</a> для его удаления, а затем откройте его снова для записи).</p>
        <p>Когда вы закончите использовать файл, вы можете использовать команду <a href="Dictionary.html#file-close">file-close</a>, чтобы завершить сеанс работы с файлом. Если вы хотите впоследствии удалить файл, используйте примитив <a href="Dictionary.html#file-delete">file-delete</a> для его удаления. Чтобы закрыть несколько открытых файлов, необходимо сначала выбрать файл с помощью, <a href="Dictionary.html#file-open">file-open</a> прежде чем закрывать его.</p>
        <pre>;; Open 3 files
file-open "myfile1.txt"
file-open "myfile2.txt"
file-open "myfile3.txt"

;; Now close the 3 files
file-close
file-open "myfile2.txt"
file-close
file-open "myfile1.txt"
file-close</pre>
        <p>Или, если вы хотите закрыть все файлы, вы можете использовать <a href="Dictionary.html#file-close-all">file-close-all</a>.</p>
        <p>Стоит отметить два примитива: <a href="Dictionary.html#file-write">file-write</a> и <a href="Dictionary.html#file-read">file-read</a>. Эти примитивы предназначены для простого сохранения и извлечения констант NetLogo, таких как числа, списки, логические значения и строки. file-write всегда будет выводить переменную таким образом, чтобы file-read мог правильно ее интерпретировать.</p>
        <pre>file-open "myfile.txt"  ;; Opening file for writing
ask turtles
  [ file-write xcor file-write ycor ]
file-close

file-open "myfile.txt"  ;; Opening file for reading
ask turtles
  [ setxy file-read file-read ]
file-close</pre>
        <h4 style="margin-left: 5%;">Предоставление пользователю возможности выбора</h4>
        <p>Примитивы <a href="Dictionary.html#user-directory">user-directory</a>, <a href="Dictionary.html#user-file">user-file</a> и <a href="Dictionary.html#user-new-file">user-new-file</a> полезны, когда вы хотите, чтобы пользователь выбрал каталог или файл для работы вашего кода.</p>
    </div>

    <h2 id="Movies">Видеоролики</h2>
    <div class="dict-entry">
        <p>В этом разделе описывается, как записать видеоролик модели NetLogo в формате «.mp4».</p>
        <p>Сначала используйте команду <a href="https://ccl.northwestern.edu/netlogo/docs/vid.html#vid:start-recorder">vid:start-recorder</a> для запуска видеорегистратора.</p>
        <p>Чтобы добавить кадр в ролик, используйте <a href="https://ccl.northwestern.edu/netlogo/docs/vid.html#vid:record-view">vid:record-view</a> либо <a href="https://ccl.northwestern.edu/netlogo/docs/vid.html#vid:record-interface">vid:record-interface</a> в зависимости от того, хотите ли вы, чтобы фильм отображал только текущий вид или всю вкладку «Интерфейс». В одном ролике разрешение будет одним из следующих:</p>
        <ul>
            <li>Разрешение, указанное при вызове vid:start-recorder width height, если вы указали разрешение. Это необязательные параметры.</li>
            <li>Разрешение вида, если вы не указали разрешение при вызове vid:start-recorder и вызове vid:record-view перед вызовом vid:record-interface.</li>
            <li>Разрешение интерфейса, если вы не указали разрешение при вызове vid:start-recorder и вызове vid:record-interface перед вызовом vid:record-view.</li>
        </ul>
        <p>Обратите внимание, что если разрешение записанного ролика не соответствует разрешению записи, оно будет масштабировано по размеру, что может привести к тому, что изображения будут выглядеть размытыми или не в фокусе.</p>
        <p>Когда вы закончите добавлять кадры, используйте <a href="https://ccl.northwestern.edu/netlogo/docs/vid.html#vid:save-recording">vid:save-recording</a>. Имя файла, в который вы хотите сохранить ролик, должно заканчиваться .mp4 — расширением для роликов в формате MP4 (воспроизводимых в QuickTime и других программах).</p>
        <pre>;; export a 30 frame movie of the view
extensions [vid]

;...

setup
vid:start-recorder
vid:record-view ;; show the initial state
repeat 30
[ go
  vid:record-view ]
vid:save-recording "out.mp4"</pre>
        <p>Ролик будет воспроизводиться с частотой 25 кадров в секунду. Чтобы повысить или понизить частоту, рассмотрите возможность использования инструмента постобработки видео.</p>
        <p>Чтобы проверить, записываете ли вы, вызовите <a href="https://ccl.northwestern.edu/netlogo/docs/vid.html#vid:recorder-status">vid:recorder-status</a>, который возвратит строку, описывающую состояние текущего рекордера.</p>
        <p>Чтобы удалить записываемый в данный момент ролик, вызовите <a href="https://ccl.northwestern.edu/netlogo/docs/vid.html#vid:reset-recorder">vid:reset-recorder</a>.</p>
        <p>Ролики, созданные при запуске в автономном режиме или при фоновом запуске в параллельном эксперименте BehaviorSpace, могут использовать только примитив vid:record-view. Ролики, созданные в графическом интерфейсе NetLogo, также могут использовать vid:record-interface и vid:record-source.</p>
        <p>Ролики NetLogo экспортируются в виде файлов MP4 в кодировке H.264. Для воспроизведения ролика в формате MP4 вы можете использовать <a href="https://www.videolan.org/vlc/index.html">VLC Player</a>, который можно бесплатно загрузить из организации VideoLAN.</p>
        <p>Ролики могут занимать много места на диске. Вероятно, вы захотите сжать их размер с помощью стороннего программного обеспечения. Программное обеспечение может предоставить вам выбор различных видов сжатия. Некоторые виды сжатия выполняются без потерь, а другие — с потерями. «С потерями» означает, что для уменьшения размера файлов некоторые детали ролика теряются. В зависимости от характера вашей модели вы можете избегать использования сжатия с потерями, например, если представление содержит мелкие детали на уровне пикселей.</p>
    </div>

    <h2 id="Perspective">Перспектива</h2>
    <div class="dict-entry">
        <p>2D- и 3D-виды показывают мир с точки зрения наблюдателя. По умолчанию наблюдатель смотрит на мир сверху вниз с положительной оси z в точке начала координат. Вы можете изменить перспективу наблюдателя с помощью команд наблюдателя <a href="Dictionary.html#follow">follow</a>, <a href="Dictionary.html#ride">ride</a> и <a href="Dictionary.html#watch">watch</a>, а также команд черепахи <a href="Dictionary.html#follow-me">follow-me</a>, <a href="Dictionary.html#ride-me">ride-me</a> и <a href="Dictionary.html#watch-me">watch-me</a>. <a href="Dictionary.html#watch-me">watch-me</a> также является командой патча и связи. В режиме follow или ride наблюдатель перемещается вместе с агентом по миру. Разница между режимами «follow» и «ride» видна только в 3D-виде. В 3D-виде пользователь может изменять расстояние за агентом с помощью мыши. Когда наблюдатель в режиме follow на нулевом расстоянии от агента, он фактически в режиме ride. Когда наблюдатель находится в режиме watch, он следит за перемещениями одной черепахи (или патча, или связи), не двигаясь. В обоих видах вы увидите, как на объекте появляется прожектор, а в 3D-виде наблюдатель поворачивается лицом к объекту. Чтобы определить, какой агент находится в фокусе, вы можете использовать репортер <a href="Dictionary.html#subject">subject</a>.</p>
    </div>

    <h2 id="Drawing">Холст</h2>
    <div class="dict-entry">
        <p>Холст представляет собой слой, на котором черепахи могут оставлять видимые отметки.</p>
        <p>На экране холст появляется поверх патчей, но под черепахами. Изначально холст пустой и прозрачный.</p>
        <p>Вы можете видеть холст, а черепахи (и патчи) — нет. Они не могут ощущать холст или реагировать на него. Холст предназначен только для того, чтобы люди могли на него посмотреть.</p>
        <p>Черепахи могут рисовать и стирать линии на рисунке с помощью команд <a href="Dictionary.html#pen-switch-status">pen-down</a> и <a href="Dictionary.html#pen-switch-status">pen-erase</a>. Когда кисть черепахи опущена (или стирает), черепаха рисует (или стирает) линию позади себя при каждом движении. Эти линии того же цвета, что и черепаха. Чтобы остановить рисование (или стирание), используйте <a href="Dictionary.html#pen-switch-status">pen-up</a>.</p>
        <p>Линии, нарисованные черепахами, обычно имеют толщину в один пиксель. Если вам нужна другая толщина, установите для переменной <a href="Dictionary.html#pen-size">pen-size</a> черепахи другое число перед рисованием (или стиранием). У новых черепах эта переменная установлена ​​в 1.</p>
        <p>Линии, созданные, когда черепаха движется способом, который не фиксирует направление, например с помощью <a href="Dictionary.html#setxy">setxy</a> или <a href="Dictionary.html#move-to">move-to</a>, будут нарисованы, как линии кратчайшего пути, подчиняющиеся топологии.</p>
        <p>Вот несколько черепах, которые раскрасили холст на сетке случайно заштрихованных патчей. Обратите внимание, как черепахи покрывают линии, а линии — цвета патчей. Здесь использовано <a href="Dictionary.html#pen-size">pen-size</a> 2:</p>
        <div style="display: flex; justify-content: center;">
            <img src="https://ccl.northwestern.edu/netlogo/docs/images/programming/drawing.gif" style="margin: 1em auto;">
        </div>
        <p>Команда <a href="Dictionary.html#stamp">stamp</a> позволяет черепахе оставить свое изображение на холсте, а <a href="Dictionary.html#stamp-erase">stamp-erase</a> удалить пиксели под ней.</p>
        <p>Чтобы стереть все на холсте, используйте команду наблюдателя <a href="Dictionary.html#clear-drawing">clear-drawing</a>. (Вы также можете использовать <a href="Dictionary.html#clear-all">clear-all</a>, который очищает и все остальное).</p>
        <h4 style="margin-left: 5%;">Импорт изображения</h4>
        <p>Команда наблюдателя <a href="Dictionary.html#import-drawing">import-drawing</a> позволяет импортировать файл изображения с диска на холст.</p>
        <p><a href="Dictionary.html#import-drawing">import-drawing</a> полезен только как фон, на который люди могут смотреть. Если вы хотите, чтобы черепахи и патчи реагировали на изображение, вам следует использовать <a href="Dictionary.html#import-pcolors">import-pcolors</a> или <a href="Dictionary.html#import-pcolors-rgb">import-pcolors-rgb</a>.</p>
        <h4 style="margin-left: 5%;">Сравнение с другими Logo</h4>
        <p>Рисование в NetLogo работает несколько иначе, чем в некоторых других Logo.</p>
        <p>Заметные различия включают в себя:</p>
        <ul>
            <li>Новые кисти для черепах подняты (т.е. не рисуют), а не опущены (т.е. рисуют).</li>
            <li>Вместо использования fence команды для ограничения черепахи внутри границ, в NetLogo вы редактируете мир и отключаете «обертывание».</li>
            <li>Нет screen-color, bgcolor, или setbg. Вы можете сделать сплошной фон, раскрасив патч, например ask patches [ set pcolor blue ].</li>
        </ul>
        <p>Функции рисования, не поддерживаемые NetLogo:</p>
        <ul>
            <li>Не существует команды window. Она используется в некоторых других Logo, чтобы позволить черепахе бродить по бесконечной плоскости.</li>
            <li>Не существует команд flood или fill для заполнения замкнутой области цветом.</li>
        </ul>
    </div>

    <h2 id="Topology">Топология</h2>
    <div class="dict-entry">
        <p>Способ подключения мира патчей может измениться. По умолчанию мир представляет собой тор, что означает, что он не ограничен, а «обертывается» — поэтому, когда черепаха проходит за край мира, она исчезает и снова появляется на противоположном краю, и каждый патч имеет одинаковое количество «патчей-соседей». Если вы находитесь на краю света, некоторые из ваших «соседей» находятся на противоположном краю.</p>
        <p>Однако вы можете изменить настройки переноса с помощью кнопки «Настройки». Если перенос не разрешен в данном направлении, то в этом направлении (x или y) мир ограничен. У участков вдоль этой границы будет менее 8 соседей, и черепахи не смогут выйти за край света.</p>
        <p>Топология мира NetLogo имеет четыре потенциальных значения: тор, прямоугольник, вертикальный цилиндр и горизонтальный цилиндр. Топология контролируется путем включения или отключения переноса в направлениях x или y. Мир по умолчанию представляет собой тор.</p>
        <p>Тор «обертывается» в обоих направлениях, а это означает, что верхний и нижний края мира соединены, а также левый и правый края. Таким образом, если черепаха выходит за правый край мира, она появляется слева и то же самое происходит сверху и снизу.</p>
        <p>Коробка не заворачивается ни в одну сторону. Мир ограничен, поэтому черепахи, пытающиеся отойти от края мира, не могут этого сделать. Обратите внимание, что участки вокруг края света имеют менее восьми соседей; в углах их три, а в остальных — пять.</p>
        <p>Горизонтальные и вертикальные цилиндры вращаются в одном направлении, но не в другом. Горизонтальный цилиндр поворачивается вертикально, поэтому верхняя часть мира соединяется с нижней, но левые и правые края ограничены. Вертикальный цилиндр является противоположностью; он переносится горизонтально, поэтому левый и правый края соединены, но верхний и нижний края ограничены.</p>
        <p>При переносе координат черепахи и связи также визуально переносятся в представлении. Если фигура черепахи или связь выходят за край, часть ее появится на другом краю. (Сами черепахи — это точки, которые не занимают места, поэтому они не могут находиться на обеих сторонах света одновременно, но на взгляд они кажутся занимающими место, потому что у них есть форма).</p>
        <p>«Обертывание» также влияет на то, как будет выглядеть наблюдение, когда вы следуете за черепахой. На торе, куда бы черепаха ни пошла, вы всегда увидите весь мир вокруг нее:</p>
        <div style="display: flex; justify-content: center;">
            <img src="https://ccl.northwestern.edu/netlogo/docs/images/programming/torus.jpg" style="margin: 1em auto;">
        </div>
        <p>В то время как в коробке или цилиндре мир имеет края, поэтому области за этими краями отображаются на экране серыми:</p>
        <div style="display: flex; justify-content: center;">
            <img src="https://ccl.northwestern.edu/netlogo/docs/images/programming/box.jpg" style="margin: 1em auto;">
        </div>
        <p>Настройки топологии также управляют поведением примитивов distance(xy), in-radius, in-cone, face(xy), and towards(xy). Топология определяет, будут ли примитивы переноситься или нет. Они всегда используют кратчайший путь, разрешенный топологией. Например, расстояние от центра патчей в левом нижнем углу (min-pxcor, min-pycor) и правом верхнем углу (max-pxcor, max-pycor) будет следующим для каждой топологии, учитывая, что min и max pxcor и pycor составляют +/-2:</p>
        <ul>
            <li>Тор — sqrt(2) ~ 1,414 (это будет одинаково для всех размеров мира, поскольку участки в торе расположены по диагонали друг к другу.)</li>
            <li>Коробка — sqrt(ширина мира^2 + высота мира^2) ~ 7,07</li>
            <li>Вертикальный цилиндр — sqrt(высота мира^2 + 1) ~ 5,099</li>
            <li>Горизонтальный цилиндр — sqrt(ширина мира^2 + 1) ~ 5,099</li>
        </ul>
        <p>Все остальные примитивы будут действовать аналогично distance. Если вы раньше использовали -nowrap примитивы в своей модели, мы рекомендуем удалить их и вместо этого изменить топологию мира.</p>
        <p>Если в вашей модели есть черепахи, которые передвигаются, вам нужно подумать о том, что с ними происходит, когда они достигают края мира, если в используемой вами топологии есть края без переноса. Есть несколько распространенных вариантов: черепаха отражается обратно в мир (систематически или случайно), черепаха выходит из системы (умирает) или черепаха скрывается. Больше нет необходимости проверять границы, используя координаты черепахи, вместо этого мы можем просто спросить NetLogo, находится ли черепаха на краю света. Есть несколько способов сделать это, самый простой — использовать примитив <a href="Dictionary.html#can-move?">can-move?</a>.</p>
        <pre>if not can-move? distance [ rt 180 ]</pre>
        <p>can-move? возвращает true, если позиция distance впереди черепахи находится внутри мира NetLogo, в противном случае — false. В этом случае, если черепаха находится на краю света, она просто возвращается туда, откуда пришла. Вы также можете использовать patch-ahead 1 != nobody вместо <a href="Dictionary.html#can-move?">can-move?</a>. Если вам нужно сделать что-то более умное, чем просто развернуться, возможно, будет полезно использовать <a href="Dictionary.html#patch-at">patch-at</a> с <a href="Dictionary.html#dxy">dx</a> и <a href="Dictionary.html#dxy">dy</a>.</p>
        <pre>if patch-at dx 0 = nobody [
  set heading (- heading)
]
if patch-at 0 dy = nobody [
  set heading (180 - heading)
]</pre>
        <p>Это проверяет, ударяется ли черепаха о горизонтальную или вертикальную стену и отскакивает от этой стены.</p>
        <p>В некоторых моделях, если черепаха не может двигаться вперед, она просто умирает (выходит из системы, как в «Кондукторе» или «Мышеловке»).</p>
        <pre>if not can-move? distance[ die ]</pre>
        <p>Если вы перемещаете черепах, используя setxy вместо forward, вам следует проверить, существует ли патч, к которому вы собираетесь перейти, поскольку setxy выдает ошибку во время выполнения, если ему заданы координаты за пределами мира. Это обычная ситуация, когда модель имитирует бесконечную плоскость, и черепах за пределами обзора нужно просто скрыть.</p>
        <pre>let new-x new-value-of-xcor
let new-y new-value-of-ycor

ifelse patch-at (new-x - xcor) (new-y - ycor) = nobody
  [ hide-turtle ]
  [ setxy new-x new-y
    show-turtle ]</pre>
        <p>Несколько моделей в Библиотеке моделей используют эту технику. Хорошими примерами являются Гравитация, N-тела и Электростатика.</p>
        <p>Команды diffuse и diffuse4 ведут себя правильно во всех топологиях. Каждый патч распространяет равное количество переменной diffuse каждому из своих соседей. Если у него меньше 8 соседей (или 4, если вы используете diffuse4), остаток остается в диффузном патче. Это означает, что общая сумма переменных патчей по всему миру остается постоянной. Однако, если вы хотите, чтобы диффузная материя по-прежнему падала с краев мира, как это было бы на бесконечной плоскости, вам все равно нужно очищать края на каждом этапе.</p>
    </div>
    
    <h2 id="Links">Связи</h2>
    <div class="dict-entry">
        <p>Связь — это агент, соединяющий двух черепах. Этих черепах иногда еще называют узлами.</p>
        <p>Связь всегда рисуется в виде линии между двумя черепахами. У связей нет местоположения, как у черепах, они не считаются находящимися на каком-либо патче и вы не можете найти расстояние от связи до другой точки.</p>
        <p>Существует два обозначения связей: ненаправленная и направленная. Направленная связь выходит (out или from) из одного узла и входит (into или to) в другой узел. Отношения родителя с ребенком можно смоделировать как направленную связь. Ненаправленная связь выглядит одинаково для обоих узлов, каждый узел имеет связь с другим узлом. Отношения между супругами или братьями и сестрами можно смоделировать как ненаправленную связь.</p>
        <p>Существует глобальный набор агентов всех связей, как и в случае с черепахами и патчами. Вы можете создавать ненаправленные связи с помощью команд <a href="Dictionary.html#create-link">create-link-with</a> и <a href="Dictionary.html#create-link">create-links-with</a>; и направленные связи с помощью команд <a href="Dictionary.html#create-link">create-link-to</a> и <a href="Dictionary.html#create-link">create-links-to</a>, <a href="Dictionary.html#create-link">create-link-from</a> и <a href="Dictionary.html#create-link">create-links-from</a>. После создания первой связи, направленной или ненаправленной, все связи без вида должны совпадать (связи также поддерживают виды, подобно черепахам, которые будут рассмотрены вскоре); невозможно иметь две несвязанные связи, одна из которых направлена, а другая ненаправлена. Если вы попытаетесь это сделать, произойдет ошибка выполнения. (Если все связи без вида погибнут, то можно создать связи этого вида, отличные по назначению от предыдущих связей).</p>
        <p>В общем, имена примитивов связей указывают, с каким типом связей они имеют дело:</p>
        <ul>
            <li>Примитивы, в названии которых есть слово «out», используют исходящие и ненаправленные связи. Вы можете думать об этом как о «связях, которые я могу использовать для перехода от текущего узла к другим узлам». В общем, это, вероятно, те примитивы, которые вы хотите использовать.</li>
            <li>Примитивы, в названии которых есть «in», используют входящие и ненаправленные связи. Вы можете думать об этом как о «связях, которые я могу использовать, чтобы добраться до текущего узла с других узлов».</li>
            <li>Примитивы, которые не указывают «in» или «out» или не содержат «with» в своем имени, используют все связи, как ненаправленные, так и направленные, входящие и исходящие.</li>
        </ul>
        <p>Переменные связи end1 и end2 содержат двух черепах, которых соединяет связь. Если связь направленная, она идет от end1 до end2. Если связь ненаправленная, end1 всегда является старшей из двух черепах, то есть черепахой с меньшим «who-number».</p>
        <p>Виды связей, как и виды черепах, позволяют определять в модели различные типы связей. Виды связей должны быть либо направленными, либо ненаправленными, в отличие от связей без вида, это определяется во время компиляции, а не во время выполнения. Вы объявляете виды связей, используя ключевые слова <a href="Dictionary.html#undirected-link-breed">undirected-link-breed</a> и <a href="Dictionary.html#directed-link-breed">directed-link-breed</a>. Связи с указанием вида можно создавать с помощью команд <a href="Dictionary.html#create-link">create-&lt;breed>-with</a> и <a href="Dictionary.html#create-link">create-&lt;breeds>-with</a> для ненаправленных связей, а также команды <a href="Dictionary.html#create-link">create-&lt;breed>-to</a>, <a href="Dictionary.html#create-link">create-&lt;breeds>-to</a>, <a href="Dictionary.html#create-link">create-&lt;breed>-from</a> и <a href="Dictionary.html#create-link">create-&lt;breeds>-from</a> для направленных связей.</p>
        <p>Между парой агентов не может быть более одной ненаправленной связи одного и того же вида (или более одной ненаправленной связи без вида), а также между парой агентов не может быть более одной направленной связи одного и того же вида в одном направлении. Между парой могут быть две направленные связи одного вида (или две направленные связи без вида), если они расположены в противоположных направлениях.</p>
        <h4 style="margin-left: 5%;">Макеты</h4>
        <p>В рамках поддержки сетей мы также добавили несколько различных примитивов, которые помогут вам визуализировать сети. Самый простой — <a href="Dictionary.html#layout-circle">layout-circle</a>, который равномерно распределяет агентов вокруг центра мира по заданному радиусу.</p>
        <div style="display: flex; justify-content: center;">
            <img src="https://ccl.northwestern.edu/netlogo/docs/images/programming/circle-layout.gif" style="margin: 1em auto;">
        </div>
        <p><a href="Dictionary.html#layout-radial">layout-radial</a> это хороший макет, если у вас есть что-то вроде древовидной структуры, хотя даже если в дереве есть несколько циклов, он все равно будет работать, хотя, поскольку циклов становится все больше и больше, это, вероятно, будет выглядеть не так хорошо. <a href="Dictionary.html#layout-radial">layout-radial</a> принимает корневой агент в качестве центрального узла, помещает его в (0,0) и располагает узлы, подключенные к нему, в концентрическом порядке. Узлы на расстоянии одного градуса от корня будут расположены по кругу вокруг центрального узла, а следующий уровень - вокруг этих узлов и так далее. <a href="Dictionary.html#layout-radial">layout-radial</a> попытается учесть асимметричные графы и предоставить больше места более широким ветвям. <a href="Dictionary.html#layout-radial">layout-radial</a> также принимает вид в качестве входных данных, поэтому для макета сети вы должны использовать один вид связей.</p>
        <div style="display: flex; justify-content: center;">
            <img src="https://ccl.northwestern.edu/netlogo/docs/images/programming/radial-layout.gif" style="margin: 1em auto;">
        </div>
        <p>Учитывая набор узлов привязки, <a href="Dictionary.html#layout-tutte">layout-tutte</a> помещает все остальные узлы в центр масс узлов, с которыми он связан. Набор привязок автоматически размещается в виде круга с заданным пользователем радиусом, а другие узлы сойдутся на своих местах (это, конечно, означает, что вам, возможно, придется запустить его несколько раз, прежде чем макет станет стабильным).</p>
        <div style="display: flex; justify-content: center;">
            <img src="https://ccl.northwestern.edu/netlogo/docs/images/programming/tutte-layout.gif" style="margin: 1em auto;">
        </div>
        <p><a href="Dictionary.html#layout-spring">layout-spring</a> полезен для многих типов сетей. Недостатком является то, что это происходит относительно медленно, поскольку для сходимости требуется много итераций. В этом макете связи действуют как пружины, которые притягивают соединяемые ими узлы друг к другу, а узлы отталкивают друг друга. Сила действий контролируется входными данными примитивов. Эти входы всегда будут иметь значение от 0 до 1; имейте в виду, что очень небольшие изменения все равно могут повлиять на внешний вид сети. Пружины также имеют длину (в патч-блоках), однако из-за всех задействованных сил узлы не окажутся точно на таком расстоянии друг от друга.</p>
    </div>

    <h2 id="Anonymous-procedures">Анонимные процедуры</h2>
    <div class="dict-entry">
        <p>Анонимные процедуры позволяют хранить код для последующего запуска. Как и обычные процедуры NetLogo, анонимные процедуры могут быть либо командой (анонимная команда), либо репортером (анонимный репортер).</p>
        <p>Анонимные процедуры представляют собой значения, что означает, что они могут передаваться в качестве входных данных, возвращаться как результат или храниться в переменной.</p>
        <p>Анонимная процедура может запускаться один, несколько раз или не запускаться вообще.</p>
        <p>В других языках программирования анонимные процедуры известны как функции первого класса, замыкания или лямбда.</p>
    </div>
    <div class="dict-entry">
        <h3>Примитивы анонимных процедур</h3>
        <p>Примитивы, специфичные для анонимных процедур ->: is-anonymous-command?, и is-anonymous-reporter?.</p>
        <p>-> создает анонимную процедуру. Анонимная процедура, которая возвращается, может быть командой или репортером, в зависимости от того, какой тип блока вы ей передаете. Например, [ -> fd 1 ] возвращает анонимную команду, потому что fd это команда, а [ -> count turtles ] возвращает анонимный репортер, потому что count это репортер.</p>
        <p>Следующие примитивы требуют в качестве входных параметров анонимные процедуры: foreach, map, reduce, filter, n-values, sort-by. При вызове этих примитивов использование -> необязательно, если ваша анонимная процедура содержит один примитив, который не требует больше входных данных, чем предоставляет примитив. Например, вместо foreach mylist print можно написать foreach mylist [ [x] -> print x ], хотя последнее тоже допускается. В зависимости от анонимной процедуры различные части синтаксиса анонимной процедуры могут быть опущены. Краткое описание необязательного синтаксиса см. в таблице ниже.</p>
        <p>Команда run принимает анонимные команды, а также строки.</p>
        <p>Репортер runresult принимает анонимные репортеры, а также строки.</p>
        <p>В run и runresult позволяется передавать в качестве входных параметров анонимную процедуру. Как и все примитивы, принимающие различное количество входных данных, весь вызов должен быть заключен в круглые скобки, например (run my-anonymous-command 5) или (runresult my-anonymous-reporter "foo" 2). Если ввод не передается, скобки не требуются.</p>
    </div>
    <div class="dict-entry">
        <h3>Входные данные анонимных процедур</h3>
        <p>Анонимная процедура может принимать ноль или более входных данных. На входные данные ссылаются переменные, объявленные перед стрелкой. Например, в анонимном репортере [ [a b] -> a + b ] a и b являются входными данными.</p>
    </div>
    <div class="dict-entry">
        <h3>Краткий синтаксис</h3>
        <p>Простое использование foreach, map, reduce, filter, n-values и sort-by может быть записано с особенно кратким синтаксисом. Вы можете написать:</p>
        <pre>map abs [1 -2 3 -4]
    ;; => [1 2 3 4]
    reduce + [1 2 3 4]
    ;; => 10
    filter is-number? [1 "x" 3]
    ;; => [1 3]
    foreach [1 2 3 4] print
    ;; prints 1 through 4</pre>
        <p>В более старых версиях NetLogo (4 и более ранних) нужно было писать:</p>
        <pre>map [abs ?] [1 -2 3 -4]
    ;; => [1 2 3 4]
    reduce [?1 + ?2] [1 2 3 4]
    ;; => 10
    filter [is-number? ?] [1 "x" 3]
    ;; => [1 3]
    foreach [1 2 3 4] [ print ? ]
    ;; prints 1 through 4</pre>
    </div>
    <div class="dict-entry">
        <h3>Анонимные процедуры как закрытия</h3>
        <p>Анонимные процедуры – это «закрытия»; это означает, что они фиксируют или «закрывают» привязки (а не только текущие значения) локальных переменных и входных данных процедуры. Они не фиксируют переменные агента и не фиксируют идентичность (или даже тип агента) текущего агента.</p>
    </div>
    <div class="dict-entry">
        <h3>Нелокальные выходы</h3>
        <p>Команды stop и report выходят из динамически включающей процедуры, а не из анонимной процедуры. (Это обратно совместимо со старыми версиями NetLogo).</p>
    </div>
    <div class="dict-entry">
        <h3>Анонимные процедуры и расширения</h3>
        <p>API расширений (extensions) поддерживает написание примитивов, которые принимают анонимные процедуры в качестве входных данных.</p>
    </div>
    <div class="dict-entry">
        <h3>Ограничения</h3>
        <p>Мы надеемся устранить хотя бы некоторые из следующих ограничений в будущих версиях NetLogo:</p>
        <ul>
            <li>import-world не поддерживает анонимные процедуры.</li>
            <li>Анонимные процедуры не могут быть вариативными (принимать различное количество входных данных).</li>
            <li>Анонимные репортеры не могут содержать команды, а только одно выражение репортера. Например, вы должны использовать ifelse-value, а не if, и не используете report вообще. Если ваш код слишком сложен, чтобы его можно было написать как один репортер, вам придется переместить код в отдельную процедуру репортера, а затем вызвать эту процедуру из вашего анонимного репортера, передав ему все необходимые входные данные.</li>
            <li>Анонимные процедуры не взаимозаменяемы с командными блоками и блоками репортеров. Только перечисленные выше примитивы принимают на вход анонимные процедуры. Примитивы управления, такие как ifelse и while и примитивы агента, такие как of и with не принимают анонимные процедуры. Например, если у меня есть анонимный репортер let r [ -> if random 2 == 0 ] и две анонимные команды , let c1 [ -> tick ] и let c2 [ -> stop ], то я не могу писать ifelse r c1 c2, я должен писать ifelse runresult r [ run c1 ] [ run c2 ].</li>
            <li>Краткий синтаксис, который можно опустить в ->, доступен только для примитивов и примитивов расширения, а не для обычных процедур. Например, если у меня есть процедура p, которая принимает на вход анонимную процедуру, ее нужно вызывать, например, p [ -> ... ], а не p [ ... ].</li>
        </ul>
    </div>
    <div class="dict-entry">
        <h3>Что значит «Опционально»?</h3>
        <p>Существует несколько различных способов написания анонимных процедур, которые позволяют пользователям опускать часть или весь синтаксис анонимной процедуры. Они обобщены в таблице ниже.</p>
        <table>
            <tr>
                <th>Что представляет собой анонимная процедура?</th>
                <th>Что можно оставить?</th>
                <th>Примеры</th>
            </tr>
            <tr style="background: #ffffff;">
                <td>Анонимная процедура представляет собой одиночный примитив</td>
                <td>
                    <ul>
                        <li>имена входов</li>
                        <li>стрелка</li>
                        <li>блочные скобки</li>
                    </ul>
                </td>
                <td><pre style="margin: 0;">foreach mylist stamp ; no inputs
    foreach mylist print ; single input
    (foreach xs ys setxy) ; multiple inputs
    map round [1.3 2.4 3.5] ; reporter, single input
    (map + [1 2 3] [4 5 6]) ; reporter, multiple inputs</pre></td>
            </tr>
            <tr style="background: #ffffff;">
                <td>Анонимная процедура не требует входных данных</td>
                <td>
                    <ul>
                        <li>имена входов</li>
                        <li>стрелка</li>
                    </ul>
                </td>
                <td><pre style="margin: 0;">foreach mylist [ print "abc" ]
    map [ 4 ] mylist</pre></td>
            </tr>
            <tr style="background: #ffffff;">
                <td>Анонимная процедура имеет ноль или один вход(ы)</td>
                <td>
                    <ul>
                        <li>скобки вокруг имен входов</li>
                    </ul>
                </td>
                <td><pre style="margin: 0;">foreach mylist [ -> stamp ] ; no inputs
    foreach mylist [ x -> print x ] ; single input
    foreach mylist [ x -> rt x fd x ] ; multiple primitives, single input
    map [ -> world-width ] mylist ; reporter, no inputs
    map [ x -> x ^ 2 ] mylist ; reporter, single input</pre></td>
            </tr>
            <tr style="background: #ffffff;">
                <td>Анонимная процедура требует более одного ввода</td>
                <td>
                    <ul>
                        <li>ничего</li>
                    </ul>
                </td>
                <td><pre style="margin: 0;">(foreach xs ys [ [ x y ] -> setx x + y ])
    (map [ [ x y ] -> x mod round y ] xs ys)</pre></td>
            </tr>
        </table>
        <p><b>Замечание:</b> В NetLogo 6.0.0 всегда требовались скобки вокруг имен входов. Если вы скопируете и вставите код в NetLogo 6.0.0, используя анонимные процедуры с входными именами без квадратных скобок, код не будет скомпилирован, пока вы не добавите скобки.</p>
    </div>

    <h2 id="Ask-concurrent">Ask-Concurrent</h2>
    <div class="dict-entry">
        <p><b>ПРИМЕЧАНИЕ: </b>Следующая информация включена только для обратной совместимости. Мы е рекомендуем использовать примитив ask-concurrent в новых моделях.</p>
        <p>В очень старых версиях NetLogo <a href="Dictionary.html#ask">ask</a> по умолчанию моделировалось согласованное выполнение. С версии NetLogo 4.0 (2007 г.) <a href="Dictionary.html#ask">ask</a> является последовательным, то есть агенты запускают команды внутри запроса по одной.</p>
        <p>Следующая информация описывает поведение команды <a href="Dictionary.html#ask-concurrent">ask-concurrent</a>, которая ведет себя так же, как вела старая <a href="Dictionary.html#ask">ask</a> команда.</p>
        <p><a href="Dictionary.html#ask-concurrent">ask-concurrent</a> создает имитацию параллелизма посредством механизма очередности. Ход делает первый агент, затем ход второго агента и так далее, пока каждый агент в заданном наборе агентов не сделает ход. Затем возвращаемся к первому агенту. Это продолжается до тех пор, пока все агенты не завершат выполнение всех команд.</p>
        <p>«Ход» агента заканчивается, когда он выполняет действие, влияющее на состояние мира, например перемещение, создание черепахи или изменение значения глобальных переменных, переменных черепах, патчей, связей. (Установка локальной переменной не учитывается).</p>
        <p>Команды <a href="Dictionary.html#forward">forward (fd)</a> и <a href="Dictionary.html#back">back (bk)</a> обрабатываются особым образом. При использовании внутри <a href="Dictionary.html#ask-concurrent">ask-concurrent</a> эти команды могут выполняться несколько раз. За свой ход черепаха может переместиться только на один шаг. Так, например, fd 20 эквивалентно repeat 20 [ fd 1 ], где ход черепахи заканчивается после каждого выполнения fd. Если указанное расстояние не является целым числом, последняя часть шага занимает полный оборот. Так, например, fd 20.3 эквивалентно repeat 20 [ fd 1 ] fd 0.3.</p>
        <p>Команда <a href="Dictionary.html#jump">jump</a> всегда занимает ровно один ход, независимо от расстояния.</p>
        <p>Чтобы понять разницу между <a href="Dictionary.html#ask">ask</a> и <a href="Dictionary.html#ask-concurrent">ask-concurrent</a>, рассмотрим следующие две команды:</p>
        <pre>ask turtles [ fd 5 ]
    ask-concurrent turtles [ fd 5 ]</pre>
        <p>При <a href="Dictionary.html#ask">ask</a>, первая черепаха делает пять шагов вперед, затем вторая черепаха делает пять шагов вперед и так далее.</p>
        <p>При <a href="Dictionary.html#ask-concurrent">ask-concurrent</a>, все черепахи делают один шаг вперед. Затем все делают второй шаг и так далее. Таким образом, последняя команда эквивалентна:</p>
        <pre>repeat 5 [ ask turtles [ fd 1 ] ]</pre>
        <p>Поведение <a href="Dictionary.html#ask-concurrent">ask-concurrent</a> не всегда можно так просто воспроизвести с помощью <a href="Dictionary.html#ask">ask</a>, как в этом примере. Рассмотрим эту команду:</p>
        <pre>ask-concurrent turtles [ fd random 10 ]</pre>
        <p>Чтобы получить такое же поведение, используя <a href="Dictionary.html#ask">ask</a>, нам придется написать:</p>
        <pre>turtles-own [steps]
    ask turtles [ set steps random 10 ]
    while [any? turtles with [steps > 0]] [
    ask turtles with [steps > 0] [
    fd 1
    set steps steps - 1
    ]
    ]</pre>
        <p>Чтобы продлить «очередь» агента, используйте команду <a href="Dictionary.html#without-interruption">without-interruption</a>. (Командные блоки внутри некоторых команд, например <a href="Dictionary.html#create-turtles">create-turtles</a> и <a href="Dictionary.html#hatch">hatch</a>, имеют подразумеваемый вставку <a href="Dictionary.html#without-interruption">without-interruption</a> вокруг них).</p>
        <p>Обратите внимание, что поведение <a href="Dictionary.html#ask-concurrent">ask-concurrent</a> полностью детерминировано. При одном и том же коде и одинаковых начальных условиях всегда будет происходить одно и то же (если вы используете одну и ту же версию NetLogo и начинаете прогон модели с одним и тем же случайным начальным значением).</p>
        <p>В общем, мы предлагаем вам ask-concurrent вообще не использовать. Если да, то мы предлагаем вам написать свою модель так, чтобы она не зависела от точных деталей того, как работает ask-concurrent. Мы не даем никаких гарантий, что его семантика останется прежней в будущих версиях NetLogo или что он вообще будет поддерживаться.</p>
    </div>

    <h2 id="User-interaction-primitives">Примитивы взаимодействия с пользователем</h2>
    <div class="dict-entry">
        <p>NetLogo имеет несколько примитивов, которые позволяют модели взаимодействовать с пользователем. Эти примитивы включают <a href="Dictionary.html#user-directory">user-directory</a>, <a href="Dictionary.html#user-file">user-file</a>, <a href="Dictionary.html#user-new-file">user-new-file</a>, <a href="Dictionary.html#user-input">user-input</a>, <a href="Dictionary.html#user-message">user-message</a>, <a href="Dictionary.html#user-one-of">user-one-of</a> и <a href="Dictionary.html#user-yes-or-no?">user-yes-or-no?</a>.</p>
        <p>Эти примитивы различаются тем, какое именно взаимодействие они осуществляют с пользователем. user-directory, user-file, и user-new-file являются репортерами, которые предлагают пользователю выбрать элемент из файловой системы и сообщают NetLogo путь к выбранному элементу. user-yes-or-no?, user-one-of, и user-input все они предлагают пользователю ввести данные в виде текста или выделения. user-message просто предоставляет сообщение пользователю.</p>
        <p>Обратите внимание, что все активные кнопки приостанавливаются при использовании одного из этих примитивов и возобновляются только тогда, когда пользователь завершает взаимодействие с кнопкой.</p>
        <p><b>Что означает кнопка «Halt»?</b></p>
        <p>Примитивы, которые запрашивают у пользователя ввод данных, а также user-message, все они предоставляют кнопку «Halt». Эффект этой кнопки одинаков для всех этих примитивов — она останавливает модель. Когда модель останавливается, весь работающий код останавливается, включая кнопки и командный центр. Поскольку кнопка «Halt» останавливает код в середине того, что он делал в момент остановки, вы можете увидеть странные результаты, если продолжите запускать модель после остановки, не настраивая ее снова.</p>
    </div>

    <h2 id="Tie">Связывание</h2>
    <div class="dict-entry">
        <p>Tie связывает двух черепах так, что движение одной черепахи влияет на местоположение и направление движения другой. Связывание — это свойство связей, поэтому между двумя черепахами должна быть связь, чтобы создать отношение связывания.</p>
        <p>Когда для связей <a href="Dictionary.html#tie-mode">tie-mode</a> установлено значение «fixed» или «free», <a href="Dictionary.html#end1">end1</a> и <a href="Dictionary.html#end2">end2</a> связаны друг с другом. Если связь направлена, <a href="Dictionary.html#end1">end1</a> это «корневой агент» и <a href="Dictionary.html#end2">end2</a> «листовой агент». То есть, когда <a href="Dictionary.html#end1">end1</a> перемещается (с использованием <a href="Dictionary.html#forward">fd</a>, <a href="Dictionary.html#jump">jump</a>, <a href="Dictionary.html#setxy">setxy</a> и т.д.), <a href="Dictionary.html#end2">end2</a> также перемещаются на то же расстояние и в том же направлении. Однако на перемещение <a href="Dictionary.html#end2">end2</a> не влияет на <a href="Dictionary.html#end1">end1</a>.</p>
        <p>Если связь ненаправленная, это взаимное отношение связи, то есть, если одна черепаха перемещается, другая черепаха также будет двигаться. Таким образом, в зависимости от того, какая черепаха движется, любую черепаху можно считать корнем или листом. Корневая черепаха всегда является той черепахой, которая инициирует движение.</p>
        <p>Когда корневая черепаха поворачивается вправо или влево, листовая черепаха вращается вокруг корневой черепахи так же, как если бы черепах соединяла жесткая конструкция. Если <a href="Dictionary.html#tie-mode">tie-mode</a> установлено значение «fixed», направление листовой черепахи изменится на такую ​​же величину. Если для параметра <a href="Dictionary.html#tie-mode">tie-mode</a> установлено значение «free», направление листовой черепахи не изменится.</p>
        <p>Для <a href="Dictionary.html#tie-mode">tie-mode</a> можно установить значение «fixed» с помощью команды <a href="Dictionary.html#tie">tie</a> и установить значение «none» (это означает, что черепахи больше не связаны), используя <a href="Dictionary.html#untie">untie</a> для установки режима «free» вам необходимо: set tie-mode "free".</p>
    </div>

    <h2 id="Multiple-source-files">Множество исходных файлов</h2>
    <div class="dict-entry">
        <p>Ключевое слово <a href="Dictionary.html#__includes">__includes</a> позволяет использовать несколько исходных файлов в одной модели NetLogo.</p>
        <p>Ключевое слово начинается с двух символов подчеркивания, указывающих на то, что эта функция является экспериментальной и может измениться в будущих выпусках NetLogo.</p>
        <p>Когда вы открываете модель, в которой используется ключевое слово <a href="Dictionary.html#__includes">__includes</a>, или добавляете ее в верхнюю часть модели и нажимаете кнопку «Проверить», на панели инструментов появляется меню «Включения». В меню «Включения» вы можете выбрать файлы, которые хотите включить в эту модель.</p>
        <p>Когда вы открываете включенные файлы, они появляются на дополнительных вкладках. Дополнительную информацию см. в <a href="https://ccl.northwestern.edu/netlogo/docs/codetab.html#included-files-menu">Interface Guide</a>.</p>
        <p>Во внешних исходных файлах (формат .nls) вы можете содержать все, что обычно помещаете на вкладку «Код»: <a href="Dictionary.html#globals">globals</a>, <a href="Dictionary.html#breed">breed</a>, <a href="Dictionary.html#turtles-own">turtles-own</a>, <a href="Dictionary.html#patches-own">patches-own</a>, <a href="Dictionary.html#turtles-own">breeds-own</a>, определения процедур и т.д. Однако обратите внимание, что все эти объявления используют одно и то же пространство имен. То есть, если вы объявите глобальный объект my-global во вкладке «Код», вы не сможете объявить глобальный объект (или что-либо еще) с именем my-global в любом файле, включенном в модель. my-global будет доступен из всех включенных файлов. То же самое было бы верно, если бы my-global была объявлена в одном из включенных файлов.</p>
    </div>

    <h2 id="Syntax">Синтаксис</h2>
    <div>
        <div class="dict-entry">
            <h3>Цвета</h3>
            <p>На вкладке «Код» и в других местах пользовательского интерфейса NetLogo код программы выделен цветом по следующей схеме:</p>
            <ul>
                <li>Ключевые слова выделены зеленым цветом</li>
                <li>Константы оранжевого цвета</li>
                <li>Комментарии серые</li>
                <li>Примитивы команд выделены синим цветом</li>
                <li>Примитивы репортеров фиолетовые</li>
                <li>Все остальное черное</li>
            </ul>
        </div>
        <div class="dict-entry">
            <h3>Примечание</h3>
            <p>Оставшаяся часть этого раздела содержит техническую терминологию, которая может быть незнакома некоторым читателям.</p>
        </div>
        <div class="dict-entry">
            <h3>Ключевые слова</h3>
            <p>Ключевыми словами в языке являются <a href="Dictionary.html#globals">globals</a>, <a href="Dictionary.html#breed">breed</a>, <a href="Dictionary.html#turtles-own">turtles-own</a>, <a href="Dictionary.html#patches-own">patches-own</a>, <a href="Dictionary.html#to">to</a>, <a href="Dictionary.html#to-report">to-report</a> и <a href="Dictionary.html#end">end</a>, а также <a href="Dictionary.html#extensions">extensions</a> и <a href="Dictionary.html#__includes">__includes</a>. (Встроенные имена примитивов не могут быть скрыты или переопределены, поэтому они, по сути, также являются своего рода ключевыми словами).</p>
        </div>
        <div class="dict-entry">
            <h3>Идентификаторы</h3>
            <p>Все примитивы, имена глобальных и агентских переменных, а также имена процедур используют одно глобальное пространство имен, нечувствительное к регистру; локальные переменные (<a href="Dictionary.html#let">let</a> переменные и имена входных данных процедуры) не могут перекрывать глобальные переменные или друг друга. Идентификаторы могут содержать любую букву или цифру Юникода, а также следующие символы ASCII:</p>
            <pre>.?=*!<>:#+/%$_^'&-</pre>
            <p>Некоторые названия примитивов начинаются с двух символов подчеркивания, указывающих на то, что они являются экспериментальными и, скорее всего, будут изменены или удалены в будущих выпусках NetLogo.</p>
        </div>
        <div class="dict-entry">
            <h3>Область видимости</h3>
            <p>NetLogo имеет лексическую область видимости. Локальные переменные (включая входные данные процедур) доступны внутри блока команд, в котором они объявлены, но недоступны процедурам, вызываемым этими командами.</p>
        </div>
        <div class="dict-entry">
            <h3>Комментарии</h3>
            <p>Символ точки с запятой (";") представляет комментарий, который длится до конца строки. Синтаксис многострочных комментариев отсутствует.</p>
        </div>
        <div class="dict-entry">
            <h3>Структура</h3>
            <p>Программа состоит из необязательных объявлений (<a href="Dictionary.html#globals">globals</a>, <a href="Dictionary.html#breed">breed</a>, <a href="Dictionary.html#turtles-own">turtles-own</a>, <a href="Dictionary.html#patches-own">patches-own</a>, <a href="Dictionary.html#turtles-own">&lt;breed>-own</a>, <a href="Dictionary.html#extensions">extensions</a>) в любом порядке, за которыми следует ноль или более определений процедур. Несколько видов могут быть определены отдельными <a href="Dictionary.html#breed">breed</a> декларациями; остальные объявления могут появляться только один раз.</p>
            <p>Каждое определение процедуры начинается с <a href="Dictionary.html#to">to</a> или <a href="Dictionary.html#to-report">to-report</a>, имени процедуры и необязательного списка входных данных в квадратных скобках. Каждое определение процедуры заканчивается <a href="Dictionary.html#end">end</a>. Между ними находится ноль или более команд.</p>
        </div>
        <div class="dict-entry">
            <h3>Команды и репортеры</h3>
            <p>Команды принимают ноль или более входных данных; входные данные — это репортеры, которые также могут принимать ноль или более входных данных. Никакие знаки препинания не разделяют и не завершают команды; никакие знаки препинания не разделяют входные данные. Идентификаторы должны быть разделены пробелами, круглыми или квадратными скобками. (Например, a+b это один идентификатор, но a(b[c]d)e содержит пять идентификаторов).</p>
            <p>Все команды являются префиксными. Все определяемые пользователем репортеры имеют префикс. Большинство примитивов репортеров являются префиксными, но некоторые (арифметические операторы, логические операторы и некоторые операторы набора агентов, такие как with и in-points) являются инфиксными.</p>
            <p>Все команды и репортеры, как примитивы, так и определяемые пользователем, по умолчанию принимают фиксированное количество входных данных. (Вот почему язык можно анализировать, хотя в нем нет знаков препинания для разделения или завершения команд и/или входных данных.) Некоторые примитивы являются вариативными, то есть могут опционально принимать другое количество входных данных, чем количество по умолчанию; Для обозначения этого используются круглые скобки, например (list 1 2 3) (поскольку <a href="Dictionary.html#list">list</a> примитив по умолчанию принимает только два входных значения). Круглые скобки также используются для переопределения приоритета операторов по умолчанию, например (1 + 2) * 3, как в других языках программирования.</p>
            <p>Иногда входными данными для примитива является командный блок (ноль или более команд в квадратных скобках) или блок репортера (одно выражение репортера в квадратных скобках). Пользовательские процедуры не могут принимать в качестве входных данных команду или блок репортеров.</p>
            <p>Приоритеты операторов следующие, от высокого к низкому:</p>
            <ul>
                <li><a href="Dictionary.html#with">with</a>, <a href="Dictionary.html#with-min">with-min</a>, <a href="Dictionary.html#with-max">with-max</a>, <a href="Dictionary.html#at-points">at-points</a>, <a href="Dictionary.html#in-radius">in-radius</a>, <a href="Dictionary.html#in-cone">in-cone</a>, <a href="Dictionary.html#who-are-not">who-are-not</a></li>
                <li><a href="Dictionary.html#of">of</a></li>
                <li>Все другие примитивы и определенные пользователем процедуры, включая <a href="Dictionary.html#not">not</a></li>
                <li>^</li>
                <li>*, /, mod</li>
                <li>+, -</li>
                <li><, >, <=, >=</li>
                <li>=, !=</li>
                <li><a href="Dictionary.html#and">and</a>, <a href="Dictionary.html#or">or</a>, <a href="Dictionary.html#xor">xor</a></li>
                <li><a href="Dictionary.html#ifelse-value">ifelse-value</a></li>
            </ul>
            <p>Если выражение содержит несколько операторов с одинаковым приоритетом, они читаются в кодовом порядке слева направо. Пример: true or false and false читается как (true or false) and false и так, в результате получается (true) and false, то есть false. Это отличается от многих других языков программирования, где or приоритет ниже, чем у and, поэтому приведенный выше оператор будет читаться как true or (false and false), true or (false), so true. Вы можете заключать выражения в круглые скобки, чтобы обеспечить желаемый порядок операций.</p>
        </div>
        <div class="dict-entry">
            <h3>Сравнение с другими Logo</h3>
            <p>Не существует согласованного стандартного определения Logo; это свободное семейство языков. Мы считаем, что NetLogo имеет достаточно общего с другими Logo, чтобы заслужить такое название. Тем не менее, NetLogo в некоторых отношениях отличается от большинства других Logo. Наиболее важные различия заключаются в следующем.</p>
            <h4 style="margin-left: 5%;">Поверхностные различия:</h4>
            <ul>
                <li>Приоритет математических операторов различен. Инфиксные математические операторы (например +, *, и т. д.) имеют более низкий приоритет, чем репортеры с именами. Например, во многих Logo, если вы напишете sin x + 1, это будет интерпретировано как sin (x + 1). NetLogo, с другой стороны, интерпретирует его так же, как и большинство других языков программирования, и так же, как то же выражение интерпретируется в стандартной математической записи, а именно как (sin x) + 1.</li>
                <li>Репортеры <a href="Dictionary.html#and">and</a> и <a href="Dictionary.html#or">or</a> — это специальные формы, а не обычные функции, и они «коротко замыкают», то есть оценивают свой второй ввод только при необходимости.</li>
                <li>Процедуры можно определить только на вкладке «Код», а не в интерактивном режиме в Командном центре.</li>
                <li>Процедуры-репортеры, то есть процедуры, которые «сообщают» (возвращают) значение, должны быть определены с помощью <a href="Dictionary.html#to-report">to-report</a> вместо <a href="Dictionary.html#to">to</a>. Команда для сообщения (возвращения) значения из процедуры репортера — <a href="Dictionary.html#report">report</a>, а не output.</li>
                <li>При определении процедуры входные данные процедуры должны быть заключены в квадратные скобки, например to square [x].</li>
                <li>Имена переменных всегда используются без знаков препинания: всегда foo, никогда :foo или "foo. (Чтобы это работало, вместо make команды, принимающей аргумент в кавычках, мы предоставляем специальную форму <a href="Dictionary.html#set">set</a>, которая не оценивает ее первый ввод). В результате процедуры и переменные занимают одно общее пространство имен.</li>
                <li>Последние три различия проиллюстрированы в следующих определениях процедур:</li>
                <div style="display: flex; margin-top: 1%;">
                    <div style="margin-left: 2%;">
                        <b>Большинство Logo:</b>
                        <pre style="margin: 0; margin-top: 10px;">to square :x
    output :x * :x
    end</pre>
                    </div>
                    <div style="margin-left: 2%;">
                        <b>NetLogo:</b>
                        <pre style="margin: 0; margin-top: 10px;">to-report square [x]
    report x * x
    end</pre>
                    </div>
                </div>
            </ul>
            <h4 style="margin-left: 5%;">Более глубокие различия:</h4>
            <ul>
                <li>Локальные переменные и входные данные процедур NetLogo имеют лексическую, а не динамическую область видимости.</li>
                <li>NetLogo не имеет типа данных «слово» (то, что Lisp называет «символами»). Со временем мы, возможно, добавим его, но поскольку он редко запрашивается, возможно, в агентном моделировании особой необходимости не возникнет. У нас есть строки. В большинстве ситуаций, когда в традиционном Logo используются слова, вместо этого мы просто используем строки. Например, в Logo вы можете написать [see spot run](список слов), но в NetLogo вместо этого вы должны написать "see spot run"(строка) или ["see" "spot" "run"](список строк).</li>
                <li>Команда NetLogo <a href="Dictionary.html#run">run</a> работает с анонимными процедурами и строками, а не со списками (поскольку у нас нет типа данных «слово») и не позволяет определять или переопределять процедуры.</li>
                <li>Структуры управления, такие как <a href="Dictionary.html#if">if</a> и <a href="Dictionary.html#while">while</a>, представляют собой специальные формы, а не обычные функции. Вы не можете определить свои собственные специальные формы, поэтому вы не можете определить свои собственные структуры управления. (Нечто подобное можно сделать, используя анонимные процедуры, но для этого необходимо использовать примитивы ->, run и runresult, их нельзя сделать неявными).</li>
                <li>Анонимные процедуры (также известные как значения функций или лямбда) являются настоящими замыканиями с лексической областью действия. Эта функция доступна в NetLogo и современном Lisps, но не доступна в стандартном Logo.</li>
            </ul>
            <p>Конечно, язык NetLogo также содержит другие функции, отсутствующие в большинстве Logo, в первую очередь агенты и agentset.</p>
        </div>
    </div>
</body> 